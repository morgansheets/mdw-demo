/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// source: web/lib/hub-ui.js
// starter globals for hub-ui
var $mdwHubRoot = 'http://localhost:8080/mdw';  // TODO: should reflect service loc
var $mdwServicesRoot = 'mdw';
var $mdwWebToolsRoot;
var $mdwVersion = '6.0.01';
var $mdwBuild;
var $mdwAutoTestWebSocketUrl;

// source: web/js/ui/actions.js
var actionsMod = angular.module('mdwActions', ['mdw']);

actionsMod.controller('MdwActionsController', ['$scope', '$window',
                                              function($scope, $window) {
  $scope.popPlace = 'left';
  
  this.getScope = function() {
    return $scope;
  };
  
  this.setPlace = function() {
    var minWidth = $scope.wrapWidth;
    if (minWidth && !$window.matchMedia('(min-width: ' + minWidth + ')').matches)
      $scope.popPlace = 'right-top';
    else
      $scope.popPlace = 'left-top';
  };
}]);

// device-specific wrap
actionsMod.directive('mdwActions', [function() {
  return {
    restrict: 'E',
    transclude: true,
    templateUrl: 'ui/mdw-actions.html',
    controller: 'MdwActionsController',
    controllerAs: 'mdwActions', 
    link: {
      pre: function(scope, elem, attrs) {
        scope.wrapWidth = attrs.wrap;
      },
      post: function(scope, elem, attrs) {
      }
    }
  };
}]);

// device-specific wrap
actionsMod.directive('mdwActionPopButton', ['$window', '$compile', function($window, $compile) {
  return {
    restrict: 'A',
    templateUrl: 'ui/action-pop-button.html',
    scope: true,
    transclude: true,
    require: '^mdwActions',
    link: {
      pre: function(scope, elem, attrs, ctrl) {
        ctrl.setPlace();
        attrs.$set("popoverPlacement", scope.popPlace);
      },
      post: function(scope, elem, attrs, ctrl) {

        if (typeof attrs.selectPop === 'undefined') { // don't automatically close these
          // try multiple generations
          var parentScope = scope.$parent;
          while (!parentScope.setPopElem && parentScope.$parent)
            parentScope = parentScope.$parent;
  
          if (parentScope.setPopElem) {
            elem.bind('click', function() {
              if (parentScope.popElem === elem) {
                // clicked to close
                parentScope.setPopElem(null);
              }
              else {
                parentScope.closePopover();
                parentScope.setPopElem(elem);
              }
            });
          }
        }
  
        var resizeHandler = function() {
          ctrl.setPlace();
          attrs.$set("popoverPlacement", scope.popPlace);
          scope.$apply();
        };
        angular.element($window).bind('resize', resizeHandler);
        scope.$on('$destroy', function() {
          angular.element($window).unbind('resize', resizeHandler);
        });
      }
    }
  };
}]);


// source: web/js/ui/chart.js
var chartMod = angular.module('mdwChart', ['mdw']);

chartMod.controller('MdwChartController', ['$scope', '$http', '$location', 'mdw', 'util', 'EXCEL_DOWNLOAD', 
                                             function($scope, $http, $location, mdw, util, EXCEL_DOWNLOAD) {
  $scope.init = function() {

    $scope.spans = ['Week', 'Month'];
    $scope.span = 'Week';
    $scope.days = 7;

    // TODO hardcoded
    $scope.initialSelect = 5;
    
    // TODO: hardcoded
    $scope.max = 50;
    
    // TODO: hardcoded
    $scope.showTotal = true;

    $scope.tops = []; // (sorted by most instances)
    $scope.selected = [];
    $scope.breakdowns = [];
    var bd = 0;
    for (var prop in $scope.breakdownConfig) {
      if ($scope.breakdownConfig.hasOwnProperty(prop) && typeof $scope.breakdownConfig[prop] === 'object') {
        $scope.breakdowns[bd] = prop;
        bd++;
      }
    }
    if ($scope.showTotal)
      $scope.breakdowns.push('Total');
    if ($scope.breakdownConfig.Status) {
      $scope.statuses = $scope.breakdownConfig.Status.throughput.slice();
    }    
    $scope.setBreakdown($scope.breakdowns[0]);    
  };

  $scope.resetFilter = function() {
    $scope.$parent.closePopover();
    $scope.filter = {
      ending: new Date()
    };
  };
  $scope.resetFilter();
  
  $scope.setStatus = function(status) {
    $scope.filter.status = status;
    $scope.updateRange();
  };
  
  $scope.chartOptions = {
    legendCallback: function(chart) {
      var text = [];
      text.push('<ul class="mdw-chart-legend">');
      for (var i = 0; i < chart.data.datasets.length; i++) {
        text.push('  <li>');
        text.push('    <span class="mdw-chart-legend-icon" style="background-color:' + chart.data.datasets[i].backgroundColor + ';' + 
            'border-color:' + chart.data.datasets[i].borderColor + '"></span>');
        var selFieldValue = chart.data.datasets[i].label;
        var top = $scope.getTop(selFieldValue);
        var label;
        var title;
        if (top) {
          label = $scope.getLabel(top, true);
          title = $scope.getTitle(top);
        }
        if (label) {
          if (title)
            text.push('    <span class="mdw-chart-legend-text" title="' + title + '">' + label + '</span>');
          else
            text.push('    <span class="mdw-chart-legend-text">' + label + '</span>');
        }
        else {
          text.push('    <span class="mdw-chart-legend-text">' + selFieldValue + '</span>');
        }
        text.push('  </li>');
      }
      text.push('</ul>');

      return text.join('\n  ');
    }
  };
  
  $scope.$on('chart-create', function (event, chart) {
    $scope.chartLegend = chart.generateLegend();
  });
  
  $scope.setSelected = function(sel) {
    $scope.selected = sel;
  };
  $scope.backupSelected = [];  // in case selection canceled
  $scope.setBackupSelected = function(backupSel) {
    $scope.backupSelected = backupSel;
  };
  
  // select popovers
  $scope.selectPop = null;
  $scope.setSelectPop = function(selPop) {
    $scope.selectPop = selPop;
  };
  $scope.closeSelectPop = function() {
    if ($scope.selectPop) {
      $scope.selectPop[0].click();
      $scope.selectPop = null;
    }
  };  

  $scope.select = function(sel) {
    if (!$scope.isSelected(sel))
      $scope.selected.push(sel);
  };
  $scope.deselect = function(sel) {
    var idx = $scope.selected.indexOf(sel);
    if (idx >= 0)
      $scope.selected.splice(idx, 1);
  };
  $scope.isSelected = function(sel) {
    return $scope.selected.includes(sel);
  };
  $scope.applySelect = function() {
    $scope.backupSelected = null;
    $scope.closeSelectPop();
    $scope.updateData();
  };
  $scope.cancelSelect = function() {
    $scope.selected = $scope.backupSelected;
    $scope.backupSelected = null;
    $scope.closeSelectPop();
  };
  
  $scope.clearRange = function() {
    $scope.dates = []; // displayed dates
    $scope.labels = [];
  };
  $scope.clearData = function() {
    $scope.series = [];
    $scope.data = [];
    $scope.total = 0;
  };
  $scope.updateDates = function() {
    // ending today unless specified in filter
    var d = new Date($scope.filter.ending.getTime());
    for (var h = 0; h < $scope.days; h++) {
      $scope.labels.unshift(util.monthAndDay(d));
      $scope.dates.unshift(util.serviceDate(d));
      if (h < $scope.days - 1)
        d.setTime(d.getTime() - util.dayMs);
    }  
    $scope.start = util.serviceDate(d);
  };
  
  $scope.updateRange = function() {
    $scope.clearData();  // prevent attempt to plot before updateData() call
    $scope.clearRange();
    $scope.updateDates();
    
    var breakdown = $scope.getBreakdown();
    if (breakdown && !Array.isArray(breakdown.throughput)) {
      var url = mdw.roots.services + breakdown.throughput;
      if (breakdown.throughput.indexOf('?') >= 0)
        url += '&';
      else
        url += '?';
      url += 'app=mdw-admin&max=' + $scope.max + '&startDate=' + $scope.start;
      if ($scope.filter.status)
        url += '&status=' + $scope.filter.status;
    
      $http.get(url).error(function(data, status) {
        console.log('HTTP ' + status + ': ' + url);
      }).success(function(data, status, headers, config) {
        $scope.tops = data;
        if ($scope.selected.length === 0) {
          // initialize to top 5
          for (var i = 0; i < $scope.tops.length; i++) {
            var val = $scope.tops[i][$scope.selField];
            if (val && $scope.selected.length < $scope.initialSelect)
              $scope.selected.push(val);
          }
        }
        $scope.updateData();
      });
    }
    else {
      // just retrieve totals
      $scope.tops = [];
      if (breakdown) {
        // hard-coded array (eg: statuses)
        $scope.selected = breakdown.throughput.slice();
        breakdown.throughput.forEach(function(tp) {
          var top = {};
          top[$scope.selField] = tp;
          $scope.tops.push(top);
        });
      }
      else {
        $scope.selected = [];
      }
      $scope.updateData();
    }
  };
  
  $scope.updateData = function() {
    
    // based on selected
    $scope.clearData();
    
    // retrieve breakdown
    var breakdown = $scope.getBreakdown();
    $scope.dataUrl = mdw.roots.services + $scope.breakdownConfig.instanceCounts;
    if ($scope.breakdownConfig.instanceCounts.indexOf('?') >= 0)
      $scope.dataUrl += '&';
    else
      $scope.dataUrl += '?';
    $scope.dataUrl += 'app=mdw-admin&startDate=' + $scope.start;
    if (breakdown && breakdown.instancesParam) 
        $scope.dataUrl += '&' + breakdown.instancesParam + '=[' + $scope.selected + ']';

    $http.get($scope.dataUrl).error(function(data, status) {
      console.log('HTTP ' + status + ': ' + $scope.dataUrl);
    }).success(function(data, status, headers, config) {
      $scope.dateObjs = data;

      // TODO: handle 'Other'
      if (breakdown) {
        $scope.selected.forEach(function(sel) {
          $scope.series.push(sel);
          var seriesData = [];
          var seriesTotal = 0;
          $scope.data.push(seriesData);
          $scope.dates.forEach(function(date) {
            var ct = 0;
            var dateCounts = $scope.dateObjs[date];
            if (dateCounts) {
              for (var k = 0; k < dateCounts.length; k++) {
                if (dateCounts[k][$scope.selField] == sel) {
                  ct = dateCounts[k].count;
                  seriesTotal += ct; 
                  break;
                }
              }
            }
            seriesData.push(ct);
          });
          var top = $scope.getTop(sel);
          if (top)
            top.seriesTotal = seriesTotal;
          $scope.total += seriesTotal; // TODO: overall total not used for breakdown
        });
      }
      else {
        // just one total per date
        var seriesData = [];
        $scope.data.push(seriesData);
        $scope.dates.forEach(function(date) {
          var ct = 0;
          var dateCounts = $scope.dateObjs[date];
          if (dateCounts && dateCounts[0])
            ct = dateCounts[0].count;
          seriesData.push(ct);
          $scope.total += ct;
        });
        $scope.series.push('Total (' + $scope.total + ')');
      }
      
      if ($scope.breakdownConfig.debug) {
        console.log('$scope.labels: ' + $scope.labels);
        console.log('$scope.series: ' + $scope.series);
        for (var l = 0; l < $scope.data.length; l++)
          console.log('$scope.data[' + l + ']: ' + $scope.data[l]);
      }
    });
  };
  
  // pass a function that returns true if the dateCount matches the added series
  $scope.addSeriesData = function(match) {
    var seriesData = [];
    var seriesTotal = 0;
    $scope.data.push(seriesData);
    $scope.dates.forEach(function(date) {
      var ct = 0;
      var dateCounts = $scope.dateObjs[date];
      if (dateCounts) {
        for (var k = 0; k < dateCounts.length; k++) {
          if (match(dateCounts[k])) {
            ct = dateCounts[k].count;
            seriesTotal += ct; 
            break;
          }
        }
      }
      seriesData.push(ct);
    });
    return seriesTotal;
  };
  
  $scope.onChartClick = function(points, evt) {
    console.log(points, evt);
  };
  
  $scope.setSpan = function(span) {
    $scope.span = span;
    $scope.days = $scope.span == 'Month' ? 30 : 7;    
    $scope.updateRange();
  };

  $scope.setBreakdown = function(breakdown) {
    $scope.breakdown = breakdown;
    if ($scope.breakdownConfig[breakdown]) {
      $scope.selField = $scope.breakdownConfig[breakdown].selectField;
      $scope.selectLabel = $scope.breakdownConfig[breakdown].selectLabel;
    }
    $scope.selected = [];
    $scope.resetFilter();
    $scope.updateRange();
  };
  // current breakdown obj (returns undefined, array or object)
  $scope.getBreakdown = function() {
    return $scope.breakdownConfig[$scope.breakdown];
  };
  
  $scope.getTop = function(selFieldValue) {
    if ($scope.tops) {
      for (var i = 0; i < $scope.tops.length; i++) {
        var top = $scope.tops[i];
        if (top[$scope.selField] === selFieldValue)
          return top;
      }
    }
  };
  $scope.getLabel = function(top, seriesTotal) {
    var breakdown = $scope.getBreakdown();
    if (breakdown && typeof breakdown.getLabel === "function") { // allow custom function 
      return breakdown.getLabel(top);
    }
    else {
      var label = top[$scope.selField];
      if ($scope.selField == 'id' && top.name)
        label = top.name;
      if (top.version)
        label += ' v' + top.version;
      if (top.definitionMissing)
        label = '[' + label + ']';
      if (top.count)
        label += ' (' + top.count + ')';
      else if (seriesTotal && typeof top.seriesTotal != 'undefined')
        label += ' (' + top.seriesTotal + ')';
      return label;
    }
  };
  $scope.getTitle = function(top) {
    var breakdown = $scope.getBreakdown();
    if (breakdown && typeof breakdown.getTitle === "function") { // allow custom function 
      return breakdown.getTitle(top);
    }
    else {
      if (top.packageName) {
        var title = top.packageName + '/' + top[$scope.selField];
        if ($scope.selField == 'id' && top.name)
          title = top.packageName + '/' + top.name;
        if (top.version)
          title += ' v' + top.version;
        if (top.definitionMissing)
          title = '[' + title + ']';
        return title;
      }
    }
  };
  
  $scope.goList = function() {
    if ($scope.listRoute) {
      $scope.$parent.getAuthUser().setActiveTab($scope.listRoute);
      $location.path($scope.listRoute.substring(1));
    }
  };
  
  $scope.downloadExcel = function() {
      window.location = $scope.dataUrl + '&' + EXCEL_DOWNLOAD;      
  };
  
}]);

chartMod.directive('mdwDashboardChart', function() {
  return {
    restrict: 'E',
    templateUrl: 'ui/chart.html',
    scope: {
      label: '@mdwChartLabel',
      breakdownConfig: '=mdwChartBreakdowns',
      listRoute: '@mdwList'
    },
    // require: ['label', 'breakdowns'],
    controller: 'MdwChartController',
    controllerAs: 'mdwChart',
    link: function link(scope, elem, attrs, ctrls) {
      scope.init();
    }
  };
});

chartMod.directive('selectPop', [function() {
  return {
    restrict: 'A',
    link: function link(scope, elem, attrs) {
      elem.bind('click', function() {
        if (scope.selectPop === elem) {
          // clicked to close
          scope.setSelectPop(null);
          if (scope.backupSelected !== null) {
            // not triggered programmatically
            scope.setSelected(scope.backupSelected);
            scope.setBackupSelected(null);
          }
        }
        else {
          scope.setSelectPop(elem);
          scope.setBackupSelected(scope.selected.slice());          
        }
      });
    }
  };
}]);
// source: web/js/ui/drawing-constants.js
var dcMod = angular.module('drawingConstants', []);

dcMod.constant('DC', {
  DEFAULT_FONT: {
    FONT: '12px sans-serif',
    SIZE: 12,
  },
  TITLE_FONT: {
    FONT: 'bold 18px sans-serif',
    SIZE: 18
  },
  DEFAULT_COLOR: 'black',
  HYPERLINK_COLOR: '#1565c0',
  LINE_COLOR: 'green',
  META_COLOR: 'gray',
  BOX_OUTLINE_COLOR: 'black',
  BOX_ROUNDING_RADIUS: 12,
  ANCHOR_W: 3,
  ANCHOR_COLOR: '#ec407a',
  ANCHOR_HIT_W: 8,
  MIN_DRAG: 3
  
});

// source: web/js/ui/editor.js
var editorMod = angular.module('mdwEditor', ['mdw']);
editorMod.constant('editorConfig', {});
  
editorMod.directive('mdwEditor', ['editorConfig', function (editorConfig) {
  
  var setOptions = function(acee, session, opts) {
    
    // TODO hardwired options
    acee.setShowPrintMargin(false);

    if (angular.isDefined(opts.basePath)) {
      var config = window.ace.require('ace/config');
      config.set('basePath', opts.basePath);      
    }
        
    if (angular.isDefined(opts.require)) {
      opts.require.forEach(function (n) {
          window.ace.require(n);
      });
    }
    
    if (angular.isDefined(opts.showGutter)) {
      acee.renderer.setShowGutter(opts.showGutter);
    }
    
    if (angular.isDefined(opts.useWrapMode)) {
      session.setUseWrapMode(opts.useWrapMode);
    }
    
    if (angular.isDefined(opts.showInvisibles)) {
      acee.renderer.setShowInvisibles(opts.showInvisibles);
    }
    
    if (angular.isDefined(opts.showIndentGuides)) {
      acee.renderer.setDisplayIndentGuides(opts.showIndentGuides);
    }
    
    if (angular.isDefined(opts.useSoftTabs)) {
      session.setUseSoftTabs(opts.useSoftTabs);
    }
    
    if (angular.isDefined(opts.showPrintMargin)) {
      acee.setShowPrintMargin(opts.showPrintMargin);
    }

    // commands
    if (angular.isDefined(opts.disableSearch) && opts.disableSearch) {
      acee.commands.addCommands([
        {
          name: 'unfind',
          bindKey: {
            win: 'Ctrl-F',
            mac: 'Command-F'
          },
          exec: function () {
            return false;
          },
          readOnly: true
        }
      ]);
    }

    if (angular.isString(opts.theme)) {
      acee.setTheme('ace/theme/' + opts.theme);
    }
    
    if (angular.isString(opts.mode)) {
      session.setMode('ace/mode/' + opts.mode);
    }
    
    // advanced options
    if (angular.isDefined(opts.firstLineNumber)) {
      if (angular.isNumber(opts.firstLineNumber)) {
        session.setOption('firstLineNumber', opts.firstLineNumber);
      } 
      else if (angular.isFunction(opts.firstLineNumber)) {
        session.setOption('firstLineNumber', opts.firstLineNumber());
      }
    }

    var key, obj;
    if (angular.isDefined(opts.advanced)) {
      for (key in opts.advanced) {
        // create a javascript object with the key and value
        obj = { name: key, value: opts.advanced[key] };
        // try to assign the option to the ace editor
        acee.setOption(obj.name, obj.value);
      }
    }

    // advanced options for the renderer
    if (angular.isDefined(opts.rendererOptions)) {
      for (key in opts.rendererOptions) {
        // create a javascript object with the key and value
        obj = { name: key, value: opts.rendererOptions[key] };
        // try to assign the option to the ace editor
        acee.renderer.setOption(obj.name, obj.value);
      }
    }

    // onLoad callbacks
    angular.forEach(opts.callbacks, function (cb) {
      if (angular.isFunction(cb)) {
        cb(acee);
      }
    });
  };

  return {
    restrict: 'EA',
    require: '?ngModel',
    link: function (scope, elem, attrs, ngModel) {
      var options = editorConfig.ace || {};
      var opts = angular.extend({}, options, scope.$eval(attrs.mdwEditor));
      var acee = window.ace.edit(elem[0]);
      acee.$blockScrolling = Infinity;
      var session = acee.getSession();
      var onChangeListener;
      var onBlurListener;
      var executeUserCallback = function () {
        var callback = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
  
        if (angular.isDefined(callback)) {
          scope.$evalAsync(function () {
            if (angular.isFunction(callback)) {
              callback(args);
            }
          });
        }
      };
      var listenerFactory = {
        onChange: function (callback) {
          return function (e) {
            var newValue = session.getValue();
  
            if (ngModel && newValue !== ngModel.$viewValue &&
                // HACK make sure to only trigger the apply outside of the
                // digest loop 'cause ACE is actually using this callback
                // for any text transformation !
                !scope.$$phase && !scope.$root.$$phase) {
              scope.$evalAsync(function () {
                ngModel.$setViewValue(newValue);
              });
            }
  
            executeUserCallback(callback, e, acee);
          };
        },
        onBlur: function (callback) {
          return function () {
            executeUserCallback(callback, acee);
          };
        }
      };
  
      attrs.$observe('readonly', function (value) {
        acee.setReadOnly(!!value || value === '');
      });
  
      if (ngModel) {
        ngModel.$formatters.push(function (value) {
          if (angular.isUndefined(value) || value === null) {
            return '';
          }
          else if (angular.isObject(value) || angular.isArray(value)) {
            throw new Error('ui-ace cannot use an object or an array as a model');
          }
          return value;
        });
  
        ngModel.$render = function () {
          session.setValue(ngModel.$viewValue);
        };
      }
  
      // listen for option updates
      var updateOptions = function (current, previous) {
        if (current === previous)
          return;
        opts = angular.extend({}, options, scope.$eval(attrs.mdwEditor));
  
        opts.callbacks = [ opts.onLoad ];
        if (opts.onLoad !== options.onLoad) {
          // also call the global onLoad handler
          opts.callbacks.unshift(options.onLoad);
        }
  
        // EVENTS
  
        // unbind old change listener
        session.removeListener('change', onChangeListener);
  
        // bind new change listener
        onChangeListener = listenerFactory.onChange(opts.onChange);
        session.on('change', onChangeListener);
  
        // unbind old blur listener
        //session.removeListener('blur', onBlurListener);
        acee.removeListener('blur', onBlurListener);
  
        // bind new blur listener
        onBlurListener = listenerFactory.onBlur(opts.onBlur);
        acee.on('blur', onBlurListener);
  
        setOptions(acee, session, opts);
      };
  
      scope.$watch(attrs.mdwEditor, updateOptions, /* deep watch */ true);
  
      updateOptions(options);
  
      elem.on('$destroy', function () {
        acee.session.$stopWorker();
        acee.destroy();
      });
  
      scope.$watch(function() {
        return [elem[0].offsetWidth, elem[0].offsetHeight];
      }, function() {
        acee.resize();
        acee.renderer.updateFull();
      }, true);
    }
  };
}]);

// source: web/js/ui/inspector-tabs.js
/* 
 * Default evaluation context for 'definitions' tabs is workflowObject,
 * and for 'instance' tabs its runtimeInfo.
 *  
 * Formats for tab declarations are described below under the first
 * example of each type.
 */

var inspectorTabSvc = angular.module('mdwInspectorTabs', ['mdw']);

inspectorTabSvc.factory('InspectorTabs', ['$http', '$q', 'mdw', function($http, $q, mdw) {
  return {
    definition: {
      process: {
        /* plain object:
         * List where prop names are labels and prop values are evaluated.
         */
        Definition: {
          Name: 'name',
          Description: 'description',
          Created: 'created' 
        },
        /* named object:
         * Tabular content evaluated against named obj collection (eg: 'variables'),
         * with prop names being labels and prop values evaluated.
         * Note: '=' refers to the identity (name) of each obj in collection
         */
        Variables: { 'variables': {
          Name: '=',
          Type: 'type',
          Mode: 'category'
        }},
        /* string:
         * Evaluated string refers to obj collection for list-type display.
         * Note: 'attributes' and 'assetAttrs' objects at the bottom of file
         * designate special behavior for assets (TODO: refactor).
         */
        Attributes: 'attributes',
        Versions: {},
        Documentation: { 
          '_attribute': { name: 'Documentation', markdown: true }
        },
        Monitoring: {}
      },
      activity: {
        Definition: {
          ID: 'id',
          Name: 'name',
          Implementor: 'implementor',
          Description: 'description'
        },
        Attributes: 'attributes',
        Documentation: { 
          '_attribute': { name: 'Documentation', markdown: true }
        },
        Monitoring: {},
        Stubbing: {}
      },
      subprocess: {
        Definition: {
          ID: 'id',
          Name: 'name',
          Description: 'description'
        },
        Attributes: 'attributes',
        Documentation: { 
          '_attribute': { name: 'Documentation', markdown: true }
        }
      },
      transition: {
        Definition: {
          ID: 'id',
          Result: 'resultCode',
          Event: 'event'
        },
        Attributes: 'attributes'
      },
      textNote: {
        Definition: {
          ID: 'id',
          Text: 'content'
        }
      }
    },
    instance: {
      process: {
        Instance: {
          'Master Request': 'masterRequestId',
          '_url': '${"#/workflow/masterRequests/" + it.masterRequestId}',
          ID: 'id',
          Status: 'status',
          Start: 'startDate',
          End: 'endDate',
          Label: 'comments'
        },
        /* named one-item array of object:
         * Name evaluates to an array which is displayed as a table with
         * each item's name/value designated by the array's single object.
         */
        Values: { 'variables': [{
          Name: 'name',
          Value: 'value',
          Type: 'type'
        }]},
        Source: {
          'Initiated By': 'owner',
          ID: 'ownerId',
          '_url': '${it.owner == "PROCESS_INSTANCE" ? "#/workflow/processes/" + it.ownerId : (it.owner == "ERROR" ? "#/workflow/triggers/" + it.ownerId : "#/workflow/requests/" + it.ownerId)}'
        }
      },
      activity: {
        /* unnamed one-item array of object:
         * Displayed as list where each instance in runtimeInfo is
         * evaluation context (prop name = label, prop value = eval). 
         */
        Instances: [{
          ID: 'id',
          '_url': '${"#/workflow/activities/" + it.id}',
          Status: 'status',
          Start: 'startDate',
          End: 'endDate',
          Result: 'statusMessage'
        }],
        /* named one-item array, followed by function:
         * Function returns an array of promises from which are extracted
         * the JSON array with the corresponding (eg: 'processInstances').
         * From these arrays each item is evaluated using the standard
         * rules of prop name = label and prop value = eval.
         * 
         * Note: Illustrates special '_url' key and also $-expressions
         * (where 'it' designates the instance item being iterated over).
         */
        Subprocesses: {
          'processInstances': [{
            ID: 'id',
            '_url': '${"#/workflow/processes/" + it.id}',
            Name: '${it.processName + " v" + it.processVersion}',
            Status: 'status',
            Start: 'startDate',
            End: 'endDate'
          }],
          'getSubprocesses': function(diagramObject, workflowObject, runtimeInfo) {
            if (typeof runtimeInfo == 'undefined') {
              // no runtimeInfo means just checking for tab applicability
              return diagramObject.workflowType == 'activity' && 
                diagramObject.implementor && diagramObject.implementor.category == 'com.centurylink.mdw.activity.types.InvokeProcessActivity';        
            }
            else {
              if (runtimeInfo === null || runtimeInfo.length === 0)
                return null;
              var subprocs = [];
              if (workflowObject.attributes.processname) {
                subprocs.push(workflowObject.attributes.processname + ' v' + workflowObject.attributes.processversion);
              }
              else if (workflowObject.attributes.processmap) {
                var attr = workflowObject.attributes.processmap;
                if (attr) {
                  var specs = attr.split(';');
                  specs.forEach(function(spec) {
                    spec = spec.replace('\\,', '~');
                    var segments = spec.split(',');
                    subprocs.push(segments[1] + ' v' + segments[2].replace('~', ','));
                  });
                }
              }
              var gets = [];
              subprocs.forEach(function(subproc) {
                var url = mdw.roots.services + '/services/Processes?definition=' + encodeURIComponent(subproc) + '&owner=PROCESS_INSTANCE&ownerId=';
                runtimeInfo.forEach(function(instance) {
                  gets.push($http.get(url + instance.processInstanceId));
                });
              });
              return $q.all(gets);
            }
          }
        },
        Tasks: {
          'tasks': [{
            ID: 'id',
            '_url': '${"#/tasks/" + it.id}',
            Name: 'name',
            Status: 'status',
            Assignee: 'assignee',
            Created: 'startDate',
            Due: 'dueDate',
            Completed: 'endDate'
          }],
          'getTasks': function(diagramObject, workflowObject, runtimeInfo) {
            if (typeof runtimeInfo == 'undefined') {
              // no runtimeInfo means just checking for tab applicability
              return diagramObject.workflowType == 'activity' && 
                diagramObject.implementor && diagramObject.implementor.category == 'com.centurylink.mdw.activity.types.TaskActivity';        
            }
            else {
              if (runtimeInfo === null || runtimeInfo.length === 0)
                return null;
              var url = mdw.roots.services + '/services/Tasks?processInstanceId=' + runtimeInfo[0].processInstanceId + '&activityInstanceIds=[';
              for (var i = 0; i < runtimeInfo.length; i++) {
                url += runtimeInfo[i].id;
                if (i < runtimeInfo.length - 1)
                  url += ",";
              }
              url += ']&sort=startDate&descending=true';
              return $http.get(url);
            }
          }
        },
        Requests: {
          'requests': [{
            ID: 'id',
            '_url': '${"#/workflow/requests/" + it.id}',
            Sent: 'created',
            Responded: 'responded'
          }],
          'getRequests': function(diagramObject, workflowObject, runtimeInfo) {
            if (typeof runtimeInfo == 'undefined') {
              // no runtimeInfo means just checking for tab applicability
              return diagramObject.workflowType == 'activity' && 
                diagramObject.implementor && diagramObject.implementor.category == 'com.centurylink.mdw.activity.types.AdapterActivity';        
            }
            else {
              if (runtimeInfo === null || runtimeInfo.length === 0)
                return null;
              var url = mdw.roots.services + '/services/Requests?type=outboundRequests&ownerIds=[';              
              for (var i = 0; i < runtimeInfo.length; i++) {
                url += runtimeInfo[i].id;
                if (i < runtimeInfo.length - 1)
                  url += ",";
              }
              url += ']&descending=true';
              return $http.get(url);
            }
          }
        },
        Responses: {
          'requests': [{
            ID: 'responseId',
            '_url': '${"#/workflow/responses/" + it.id}',
            Sent: 'created',
            Responded: 'responded'
          }],
          'getResponses': function(diagramObject, workflowObject, runtimeInfo) {
            if (typeof runtimeInfo == 'undefined') {
              // no runtimeInfo means just checking for tab applicability
              return diagramObject.workflowType == 'activity' && 
                diagramObject.implementor && diagramObject.implementor.category == 'com.centurylink.mdw.activity.types.AdapterActivity';        
            }
            else {
              if (runtimeInfo === null || runtimeInfo.length === 0)
                return null;
              var url = mdw.roots.services + '/services/Requests?type=outboundRequests&ownerIds=[';              
              for (var i = 0; i < runtimeInfo.length; i++) {
                url += runtimeInfo[i].id;
                if (i < runtimeInfo.length - 1)
                  url += ",";
              }
              url += ']&descending=true';
              return $http.get(url);
            }
          }
        }
      },
      subprocess: {
        Instances: [{
          ID: 'id',
          Status: 'status',
          Start: 'startDate',
          End: 'endDate'
        }]
      }
    },
    // TODO: refactor this into Attributes tab itself
    attributes: {
      Documentation: { exclude: true },
      Rule: { alias: 'Script', langAttr: 'SCRIPT'},
      SCRIPT: { alias: 'Language' }
    },
    assetAttrs: [
      // beyond those identified by _assetVersion
      'TASK_PAGELET' 
    ]
  };
}]);

// source: web/js/ui/inspector.js
var inspectMod = angular.module('mdwInspector', ['mdw']);

inspectMod.controller('MdwInspectorController', ['$scope', '$parse', 'mdw', 'util', 'Inspector', 'InspectorTabs',
                                                 function($scope, $parse, mdw, util, Inspector, InspectorTabs) {
  
  $scope.setWorkflow = function(obj) {
    $scope.diagramObject = obj;
    $scope.workflowType = obj.workflowType;
    $scope.workflowObject = obj[obj.workflowType];
    $scope.runtimeInfo = null;  // can be object or array
    
    if ($scope.workflowType == 'process')
      $scope.runtimeInfo = $scope.diagramObject.instance;
    else
      $scope.runtimeInfo = $scope.diagramObject.instances;
    
    if ($scope.runtimeInfo)
      $scope.tabs = InspectorTabs.instance[$scope.workflowType];
    else
      $scope.tabs = InspectorTabs.definition[$scope.workflowType];
    
    var filteredTabs = {};
    util.getProperties($scope.tabs).forEach(function(tabName) {
      var tab = $scope.tabs[tabName];
      if (typeof tab === 'object') {
        var tabProps = util.getProperties(tab);
        if (tabProps[0] && typeof tab[tabProps[1]] == 'function') {
          if (tab[tabProps[1]]($scope.diagramObject, $scope.workflowObject))
            filteredTabs[tabName] = tab;
        }
        else {
          filteredTabs[tabName] = tab;
        }
      }
      else {
        filteredTabs[tabName] = tab;
      }
    });
    $scope.tabs = filteredTabs;
    
    var sameActiveTab = $scope.tabs[$scope.activeTabName];
    if (sameActiveTab) {
      $scope.setActiveTab($scope.activeTabName);
    }
    else {
      // first tab
      $scope.setActiveTab(util.getProperties($scope.tabs)[0]);
    }
  };
  
  $scope.setActiveTab = function(tabName) {
    $scope.drilledValue = null;
    $scope.activeTabName = tabName;
    $scope.activeTab = $scope.tabs[tabName];
    $scope.activeTabValues = [];

    var tabInfo = $scope.runtimeInfo ? $scope.runtimeInfo : $scope.workflowObject;
    
    // check for array type
    var tabArr;
    if ($scope.activeTab instanceof Array) {
      // array is runtime obj itself (eg: instance.activity.Instances)
      tabArr = angular.copy($scope.activeTab);
      util.getProperties(tabArr[0]).forEach(function(tabProp) {
        var v = tabArr[0][tabProp];
        if (v.startsWith('${') && v.endsWith('}')) {
          $scope.runtimeInfo.forEach(function(rt) {
            var evalsTo = $parse(v.substring(2, v.length - 1))({it: rt});
            rt[tabProp] = evalsTo;
          });
          tabArr[0][tabProp] = tabProp;
        }
      });
    }
    else if (typeof $scope.activeTab == 'function') {
    }
    else if (typeof $scope.activeTab === 'object') {
      var tabProps = util.getProperties($scope.activeTab);
      if (tabProps[0]) {
        if ($scope.activeTab[tabProps[0]] instanceof Array) {
          if (typeof $scope.activeTab[tabProps[1]] == 'function') {
            // array is first prop, function is second (eg: instance.activities.Subprocesses)
            var listName = tabProps[0];
            tabArr = $scope.activeTab[listName];
            var passedTabArr = [{}]; 
            var itsObj = $scope.activeTab[tabProps[0]][0];
            var itsProps = util.getProperties(itsObj);
            var promise = $scope.activeTab[tabProps[1]]($scope.diagramObject, $scope.workflowObject, $scope.runtimeInfo);
            if (promise) {
              promise.then(function(res) {
                var resArr;
                if (res instanceof Array)
                  resArr = res;
                else
                  resArr = [res];
                var tabInfo = [];
                resArr.forEach(function(result) {
                  result.data[listName].forEach(function(it) {
                    var item = {};
                    itsProps.forEach(function(itsProp) {
                      var itsSpec = itsObj[itsProp];
                      if (itsSpec.startsWith('${') && itsSpec.endsWith('}')) {
                        var evalsTo = $parse(itsSpec.substring(2, itsSpec.length - 1))({it: it});
                        item[itsProp] = evalsTo;
                        passedTabArr[0][itsProp] = itsProp;
                      }
                      else {
                        // straight prop
                        item[itsSpec] = it[itsSpec];
                        passedTabArr[0][itsProp] = itsSpec;
                      }
                    });
                    tabInfo.push(item);
                  });
                });
                $scope.applyTabArray(passedTabArr, tabInfo);
              });
            }
            return;
          }
          else {
            // array is only object property (eg: instance.process.Values)
            tabArr = $scope.activeTab[tabProps[0]];
            tabInfo = tabInfo[tabProps[0]];
            if ($scope.runtimeInfo && $scope.workflowObject[tabProps[0]]) {
              // special handling in case workflowObj specifies values not in runtime
              var wfArrObj = $scope.workflowObject[tabProps[0]];
              var wfArrObjProps = util.getProperties(wfArrObj);
              wfArrObjProps.forEach(function(wfArrObjProp) {
                var found;
                for (var n = 0; n < tabInfo.length; n++) {
                  if (tabInfo[n].name == wfArrObjProp) {
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  var toAdd = wfArrObj[wfArrObjProp];
                  toAdd.name = wfArrObjProp;
                  tabInfo.push(toAdd);
                }
              });
            }
          }
        }
        else if (typeof $scope.activeTab[tabProps[0]] === 'object') {
          if (tabProps[0] === '_attribute') {
            var attrname = $scope.activeTab[tabProps[0]].name;
            $scope.activeTabValues.push({
              name: attrname,
              value: tabInfo.attributes[attrname],
              isMarkdown: $scope.activeTab[tabProps[0]].markdown
            });
          }
          else {
            // named object equates to array (eg: process.definition.Variables)
            var arrObj = angular.copy($scope.activeTab[tabProps[0]]);
            var arrObjProps = util.getProperties(arrObj);
            $scope.idProp = null;
            for (var m = 0; m < arrObjProps.length; m++) {
              if (arrObj[arrObjProps[m]] == '=') {
                $scope.idProp = arrObjProps[m];
                break;
              }
            }
            if ($scope.idProp)
              arrObj[$scope.idProp] = $scope.idProp;
            tabArr = [arrObj];
            var tabInfoObj = tabInfo[tabProps[0]];
            tabInfo = []; // to populate from object
            var tabInfoObjProps = util.getProperties(tabInfoObj);
            tabInfoObjProps.forEach(function(tabInfoObjProp) {
              tabInfo.push(tabInfoObj[tabInfoObjProp]);
              if ($scope.idProp) {
                tabInfo[tabInfo.length-1][$scope.idProp] = tabInfoObjProp;
              }
            });
          }
        }
      }
    }
    
    if (tabArr) {
      $scope.applyTabArray(tabArr, tabInfo);
    }
    else if (typeof $scope.activeTab === 'object' && !$scope.activeTab._attribute) {
      // evaluate each object prop against tabInfo object
      var tabObj = tabInfo;
      var atProps = util.getProperties($scope.activeTab);
      for (var i = 0; i < atProps.length; i++) {
        var atProp = atProps[i];
        var v = $scope.activeTab[atProp];
        if (v.startsWith('${') && v.endsWith('}')) {
          var evalsTo = $parse(v.substring(2, v.length - 1))({it: tabObj});
          if (evalsTo !== null)
            tabObj[$scope.activeTab[atProp]] = evalsTo;
        }
        if (atProp == '_url' && tabObj[$scope.activeTab[atProp]]) {
          $scope.activeTabValues[i-1].url = tabObj[$scope.activeTab[atProp]];
        }
        else {
          $scope.activeTabValues.push({
            name: atProp,
            value: tabObj[$scope.activeTab[atProp]]
          });
        }
      }
    }
    else {
      // string indicates value is an object property name on tabInfo (object)
      tabInfo = tabInfo[$scope.activeTab];
      for (var prop in tabInfo) {
        if (tabInfo.hasOwnProperty(prop)) {
          var spec = InspectorTabs[$scope.activeTab] ? InspectorTabs[$scope.activeTab][prop] : null;
          if (!spec || !spec.exclude) {
            var val = {
              name: prop,
              value: tabInfo[prop]
            };
            if (typeof val.value === 'object')
              val.value = JSON.stringify(val.value);
            if (val.value.indexOf('\n') >= 0) {
              val.full = val.value;
              val.value = val.full.getLines()[0] + ' ...';
              val.extended = true;
            }
            else if (val.value.indexOf('${props[') >= 0 || val.value.indexOf('#{props[') >= 0) {
              val.extended = true;
            }
            if (spec) {
              if (spec.alias)
                val.name = spec.alias;
              // for attributes with languages
              if (spec.langAttr)
                val.language = tabInfo[spec.langAttr] ? tabInfo[spec.langAttr].toLowerCase() : null;
              else
                val.language = spec.language;
            }
            else {
              // asset attrs
              if (prop.endsWith('_assetVersion')) {
                val.name = prop.substring(0, prop.length - 13);
                val.asset = { 
                  path: tabInfo[val.name], 
                  version: 'v' + tabInfo[prop]
                };
              }
              else if (prop == 'processname') {
                val.name = 'Process';
                val.asset = {
                  path: val.value + '.proc', 
                  version: 'v' + tabInfo.processversion
                };
              }
              else if (prop == 'processmap') {
                // TODO
              }
              else if (prop == 'Java') {
                val.language = 'java';
              }
              if (InspectorTabs.assetAttrs.indexOf(prop) != -1) {
                val.asset = { path: tabInfo[prop] };
              }
              if (val.asset && val.asset.path) {
                val.value = val.asset.path;
                if (val.asset.version)
                  val.value += ' ' + val.asset.version;
                val.asset.url = '#/asset/' + val.asset.path;
              }
            }
            if (!tabInfo[prop + '_assetVersion'] && prop != 'processversion')
              $scope.activeTabValues.push(val);
          }          
        }
      }
    }
  };
  
  $scope.applyTabArray = function(tabArr, tabInfo) {
    // indicates columnar display and tabInfo is array
    var maxColWidth = 50;
    var colSpacing = 3;
    var props = util.getProperties(tabArr[0]);
    
    var colWidths = [];
    var labels = [];
    props.forEach(function(prop) {
      labels.push(prop);
      colWidths.push(prop.length);
    });

    var values = []; // 2d
    tabInfo.forEach(function(rowObj) {
      var valueRow = [];
      for (var h = 0; h < props.length; h++) {
        var value = { value: rowObj[tabArr[0][props[h]]] };
        if (!value.value)
          value.value = '';
        value.value = '' + value.value; // convert to str
        if (value.value.length > maxColWidth) {
          value.full = value.value;
          value.value = value.full.substring(0, maxColWidth - 5) + ' ...';
          value.extended = true;
        }
        if (value.value.length > colWidths[h])
          colWidths[h] = value.value.length;
        valueRow.push(value);
      }
      values.push(valueRow);
    });

    
    // column labels
    var names = [];
    for (var k = 0; k < labels.length; k++) {
      if (labels[k] != '_url') {
        var name = { name: labels[k]};
        if (k < labels.length - 1)
          name.pad = util.padTrailing('', colWidths[k] - labels[k].length + colSpacing);
        names.push(name);
      }
    }
    // row values
    for (var i = 0; i < values.length; i++) {
      var fields = [];
      for (var j = 0; j < values[i].length; j++) {
        var field = values[i][j];
        if (field.value.startsWith('DOCUMENT:')) {
          field.url = '#/workflow/processes/' + $scope.workflowObject.id + '/values/' + fields[j-1].value;
        }
        if (labels[j] == '_url') {
          // applies to previous field
          fields[j-1].url = field.value;
        }
        else {
          if (j < values[i].length - 1)
            field.pad = util.padTrailing('', colWidths[j] - field.value.length + colSpacing);
          fields.push(field);
        }
      }
      if (i === 0) // only first element needs names
        $scope.activeTabValues.push({names: names, values: fields});
      else
        $scope.activeTabValues.push({values: fields});
    }
  };
  
  $scope.drillIn = function(tabValue) {
    $scope.drilledValue = tabValue;
    if (tabValue && tabValue.value) {
      var propStart = tabValue.value.indexOf('${props[');
      if (propStart < 0)
        propStart = tabValue.value.indexOf('#{props[');
      if (propStart >= 0) {
        var propEnd = tabValue.value.indexOf('}', 9);
        if (propEnd > propStart + 10) {
          $scope.drilledValue.full = tabValue.value + ' --> ';
          var propName = tabValue.value.substring(propStart + 9, propEnd - 2);
          var mdwProps = util.getMdwProperties();
          if (mdwProps) {
            if (propStart > 0)
              $scope.drilledValue.full += tabValue.value.substring(0, propStart);
            $scope.drilledValue.full += mdwProps[propName] + tabValue.value.substring(propEnd + 1);
          }
          else {
            util.loadMdwProperties().then(function(response) {
              mdwProps = util.getMdwProperties();
              if (propStart > 0)
                $scope.drilledValue.full += tabValue.value.substring(0, propStart);
              $scope.drilledValue.full += mdwProps[propName] + tabValue.value.substring(propEnd + 1);
            });
          }
        }
      }
    }
  };
}]);

inspectMod.factory('Inspector', ['mdw', 'util', function(mdw, util) {
  return {
    setObj: function(obj, show) {
      this.obj = obj;
      if (this.listener) {
        this.listener(obj, show);
      }
    },
    getObj: function() {
      return this.obj;
    },
    listen: function(listener) {
      this.listener = listener;
    },
    unlisten: function() {
      this.listener = null;
    }
  };
}]);

inspectMod.directive('mdwInspector', ['$window', 'Inspector', function($window, Inspector) {
  return {
    restrict: 'A',
    controller: 'MdwInspectorController',
    link: function link(scope, elem, attrs, ctrls) {
      
      var workflowElem = elem.parent();
      var canvasElem = angular.element(workflowElem[0].getElementsByClassName('mdw-canvas'));
      var panelElem = angular.element(elem[0].getElementsByClassName('mdw-inspector-panel'));

      scope.openInspector = function() {
        elem[0].style.left = workflowElem[0].getBoundingClientRect().left + 'px';
        scope.initInspector();
        elem[0].style.display = 'block';
      };
      scope.closeInspector = function() {
        elem[0].style.display = 'none';
        workflowElem[0].style.height = canvasElem[0].offsetHeight + 'px';
      };
      scope.maxInspector = function() {
        angular.element(elem[0].getElementsByClassName('mdw-inspector-content'))[0].style.height = '100%';        
        elem[0].style.height = '80%';
        elem[0].style.top = '100px';
        panelElem[0].style.height = '90%';
      };
      // removes extra styling added by max or close
      scope.initInspector = function() {
        angular.element(elem[0].getElementsByClassName('mdw-inspector-content'))[0].style.height = '';        
        elem[0].style.height = '';
        elem[0].style.top = '';
        panelElem[0].style.height = '';
      };
      
      // show
      Inspector.listen(function(obj, show) {
        scope.setWorkflow(obj);
        scope.$apply();
        
        if (show) {
          if (elem[0].style.display == 'none') {
            scope.openInspector();
          }
          
          // set workflow element height to accommodate inspector
          workflowElem[0].style.height = (canvasElem[0].offsetHeight + panelElem[0].offsetHeight - 50) + 'px';
  
          if (obj.workflowType != 'process') {
            // scroll into view
            var objBtmY = canvasElem[0].getBoundingClientRect().top + obj.display.y + obj.display.h;
            var inspTopY = elem[0].getBoundingClientRect().top;
            if (objBtmY > inspTopY)
              $window.scrollBy(0, objBtmY - inspTopY + 10);
          }
        }
      });
      
      scope.$on('$destroy', function() {
        Inspector.unlisten();
      });
    }
  };
}]);
// source: web/js/ui/label.js
var labelMod = angular.module('mdwLabel', ['mdw']);

labelMod.factory('Label', ['$document', 'mdw', 'util', 'Shape', 'DC',
                   function($document, mdw, util, Shape, DC) {
  
  var Label = function(owner, text, display, font) {
    Shape.call(this);
    this.owner = owner;
    this.diagram = owner.diagram;
    this.text = text;
    this.display = display; // just x, y except for process owner
    this.font = font;
    this.workflowItem = owner.workflowItem;
    this.isLabel = true;
  };
  
  Label.prototype = new Shape();
  
  Label.SEL_COLOR = '#e91e63';
  Label.SEL_PAD = 4;
  Label.SEL_ROUNDING_RADIUS = 4;
  
  Label.prototype.draw = function(color) {
    if (this.font)
      this.diagram.context.font = this.font.FONT;
    this.diagram.context.fillStyle = color ? color : DC.DEFAULT_COLOR;
    this.diagram.context.clearRect(this.display.x, this.display.y, this.display.w, this.display.h);
    this.diagram.context.fillText(this.text, this.display.x, this.display.y + this.display.h / 1.33);
    this.diagram.context.font = DC.DEFAULT_FONT.FONT;
    this.diagram.context.fillStyle = DC.DEFAULT_COLOR;
  };
  
  Label.prototype.prepareDisplay = function() {
    if (this.font)
      this.diagram.context.font = this.font.FONT;
    var textMetrics = this.diagram.context.measureText(this.text);
    this.display.w = textMetrics.width;
    this.display.h = this.font.SIZE;
    var maxDisplay = { w: this.display.w + this.display.x, h: this.display.h + this.display.y };
    this.diagram.context.font = DC.DEFAULT_FONT.FONT;
    return maxDisplay;
  };
  
  Label.prototype.select = function() {
    var x = this.display.x - Label.SEL_PAD;
    var y = this.display.y - Label.SEL_PAD;
    var w = this.display.w + Label.SEL_PAD + 2;
    var h = this.display.h + Label.SEL_PAD;
    this.diagram.rect(x, y, w, h, Label.SEL_COLOR, null, Label.SEL_ROUNDING_RADIUS);
  };
  
  Label.prototype.move = function(deltaX, deltaY) {
    var x = this.display.x + deltaX;
    var y = this.display.y + deltaY;
    this.setDisplayAttr(x, y, this.display.w, this.display.h); 
  };
  
  return Label;
}]);
// source: web/js/ui/link.js
var linkMod = angular.module('mdwLink', ['mdw']);

linkMod.factory('Link', ['mdw', 'util', 'DC', 'Label',
                         function(mdw, util, DC, Label) {

  var Link = function(diagram, transition, from, to) {
    this.diagram = diagram;
    this.transition = this.workflowItem = transition;
    this.from = from;
    this.to = to;
    this.workflowType = 'transition';
    this.isLink = true;
  };
  
  Link.INITIATED = 'blue';
  Link.TRAVERSED = 'black';
  Link.UNTRAVERSED = '#9e9e9e';
  Link.GAP = 4;
  Link.CR = 8;
  Link.LINK_WIDTH = 3;
  Link.LINK_HIT_WIDTH = 8;
  Link.CORR = 3; // offset for link start points
  Link.LABEL_CORR = 3;

  Link.EVENTS = {
    START: {color: 'green'},
    RESUME: {color: 'green'},
    DELAY: {color: 'orange'},
    HOLD: {color: 'orange'},
    ERROR: {color: 'red'},
    ABORT: {color: 'red'},
    CORRECT: {color: 'purple'},
    FINISH: {color: 'gray'}
  };
  
  Link.LINK_TYPES = {
    STRAIGHT: 'Straight',
    ELBOW: 'Elbow',
    ELBOWH: 'ElbowH',
    ELBOWV: 'ElbowV'      
  };
  
  Link.AUTO_ELBOW_LINK_TYPES = {
    AUTOLINK_H: 1,
    AUTOLINK_V: 2,
    AUTOLINK_HV: 3,
    AUTOLINK_VH: 4,
    AUTOLINK_HVH: 5,
    AUTOLINK_VHV: 6      
  };
  
  Link.ELBOW_THRESHOLD = 0.8;
  Link.ELBOW_VH_THRESHOLD = 60;
  
  Link.prototype.draw = function() {
    var color = Link.EVENTS[this.transition.event].color;
    if (this.diagram.instance) {
      if (this.instances && this.instances.length > 0) {
        var latest = this.instances[0];
        if (latest.statusCode == 1)
          color = Link.INITIATED;
        else
          color = Link.TRAVERSED;
      }
      else {
        color = Link.UNTRAVERSED;
      }
    }
      
    this.diagram.context.strokeStyle = color;
    this.diagram.context.fillStyle = color;
    this.drawConnector();

    if (this.label) {
      if (this.diagram.instance && (!this.instances || this.instances.length === 0))
        this.label.draw(Link.UNTRAVERSED);
      else
        this.label.draw();
    }

    this.diagram.context.strokeStyle = DC.DEFAULT_COLOR;    
  };
  
  // sets display/label and returns an object with w and h for required size
  Link.prototype.prepareDisplay = function() {
    var maxDisplay = { w: 0, h: 0};
    this.display = this.getDisplay();
    // TODO determine effect on maxDisplay
    
    // label
    var labelText = this.transition.event === 'FINISH' ? '' : this.transition.event + ':';
    labelText += this.transition.resultCode ? this.transition.resultCode : '';
    if (labelText.length > 0) {
      this.label = new Label(this, labelText, { x: this.display.lx, y: this.display.ly + Link.LABEL_CORR }, DC.DEFAULT_FONT);
      this.label.prepareDisplay();
    }

    return maxDisplay;
  };
  
  Link.prototype.getDisplay = function() {
    var display = {};
    var displayAttr = this.transition.attributes.TRANSITION_DISPLAY_INFO;
    if (displayAttr) {
      var vals = displayAttr.split(',');
      display.xs = [];
      display.ys = [];
      vals.forEach(function(val) {
        if (val.startsWith('lx='))
          display.lx = parseInt(val.substring(3));
        else if (val.startsWith('ly='))
          display.ly = parseInt(val.substring(3));
        else if (val.startsWith('xs=')) {
          val.substring(3).split('&').forEach(function(x) {
            display.xs.push(parseInt(x));
          });
        }
        else if (val.startsWith('ys=')) {
          val.substring(3).split('&').forEach(function(y) {
            display.ys.push(parseInt(y));
          });
        }
        else if (val.startsWith('type='))
          display.type = val.substring(5);
      });
    }
    return display;
  };
  
  Link.prototype.setDisplay = function(display) {
    if (!this.transition.attributes)
      this.transition.attributes = {};
    var attr = 'type=' + display.type + ',lx=' + display.lx + ',ly=' + display.ly;
    attr += ',xs=';
    for (var i = 0; i < display.xs.length; i++) {
      if (i > 0)
        attr += '&';
      attr += display.xs[i];
    }
    attr += ',ys=';
    for (i = 0; i < display.ys.length; i++) {
      if (i > 0)
        attr += '&';
      attr += display.ys[i];
    }
    this.transition.attributes.TRANSITION_DISPLAY_INFO = attr;
  };
  
  // only for the label
  Link.prototype.setDisplayAttr = function(x, y, w, h) {
    this.setDisplay({ lx: x, ly: y, type: this.display.type, xs: this.display.xs, ys: this.display.ys });
  };
  
  Link.prototype.applyState = function(transitionInstances) {
    this.instances = transitionInstances;
  };
  
  // if hitX and hitY are passed, checks for hover instead of stroking
  Link.prototype.drawConnector = function(hitX, hitY) {
    var context = this.diagram.context;
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    
    var hit = false;
    
    var previousLineWidth = context.lineWidth;
    if (hitX)
      context.lineWidth = Link.LINK_HIT_WIDTH;
    else
      context.lineWidth = Link.LINK_WIDTH;
    if (!type || type.startsWith('Elbow')) {
      if (xs.length == 2) {
        hit = this.drawAutoElbowConnector(context, hitX, hitY);
      }
      else {
        // TODO: make use of Link.CORR
        context.beginPath();
        var horizontal = ys[0] == ys[1] && (xs[0] != xs[1] || xs[1] == xs[2]);
        context.moveTo(xs[0], ys[0]);
        for (var i = 1; i < xs.length; i++) {
          if (horizontal) {
            context.lineTo(xs[i] > xs[i-1] ? xs[i] - Link.CR : xs[i] + Link.CR, ys[i]);
            if (i < xs.length - 1)
              context.quadraticCurveTo(xs[i], ys[i], xs[i], ys[i+1] > ys[i] ? ys[i] + Link.CR : ys[i] - Link.CR);
          }
          else {
              context.lineTo(xs[i], ys[i] > ys[i - 1] ? ys[i] - Link.CR : ys[i] + Link.CR);
              if ( i <xs.length - 1)
                context.quadraticCurveTo(xs[i], ys[i], xs[i+1] > xs[i] ? xs[i] + Link.CR : xs[i] - Link.CR, ys[i]);
          }
          horizontal = !horizontal;
        }
        if (hitX)
          hit = context.isPointInStroke(hitX, hitY);
        else
          context.stroke();
      }
    }
    
    if (!hit)
      hit = this.drawConnectorArrow(context, hitX, hitY);

    context.lineWidth = previousLineWidth;
    
    return hit;
  };
  
  Link.prototype.drawAutoElbowConnector = function(context, hitX, hitY) {
    var xs = this.display.xs;
    var ys = this.display.ys;
    var t;
    var xcorr = xs[0] < xs[1] ? Link.CORR : -Link.CORR;
    var ycorr = ys[0] < ys[1] ? Link.CORR : -Link.CORR;
    context.beginPath();
    switch (this.getAutoElbowLinkType()) {
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_H:
        context.moveTo(xs[0] - xcorr, ys[0]);
        context.lineTo(xs[1], ys[1]);
        break;
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_V:
        context.moveTo(xs[0], ys[0] - ycorr);
        context.lineTo(xs[1], ys[1]);
        break;
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HVH:
        t = (xs[0] + xs[1]) / 2;
        context.moveTo(xs[0] - xcorr, ys[0]);
        context.lineTo(t > xs[0] ? t - Link.CR : t + Link.CR, ys[0]);
        context.quadraticCurveTo(t, ys[0], t, ys[1] > ys[0] ? ys[0] + Link.CR : ys[0] - Link.CR);
        context.lineTo(t, ys[1] > ys[0] ? ys[1] - Link.CR : ys[1] + Link.CR);
        context.quadraticCurveTo(t, ys[1], xs[1] > t ? t + Link.CR : t - Link.CR, ys[1]);
        context.lineTo(xs[1], ys[1]);
        break;
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VHV:
        t = (ys[0] + ys[1]) / 2;
        context.moveTo(xs[0], ys[0] - ycorr);
        context.lineTo(xs[0], t > ys[0] ? t - Link.CR : t + Link.CR);
        context.quadraticCurveTo(xs[0], t, xs[1] > xs[0] ? xs[0] + Link.CR : xs[0] - Link.CR, t);
        context.lineTo(xs[1] > xs[0] ? xs[1] - Link.CR : xs[1] + Link.CR, t);
        context.quadraticCurveTo(xs[1], t, xs[1], ys[1] > t ? t + Link.CR : t-Link.CR);
        context.lineTo(xs[1], ys[1]);
        break;
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HV:
        context.moveTo(xs[0] - xcorr, ys[0]);
        context.lineTo(xs[1] > xs[0] ? xs[1] -Link.CR : xs[1] + Link.CR, ys[0]);
        context.quadraticCurveTo(xs[1], ys[0], xs[1], ys[1] > ys[0] ? ys[0] + Link.CR : ys[0] - Link.CR);
        context.lineTo(xs[1], ys[1]);
        break;
      case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VH:
        context.moveTo(xs[0], ys[0] - ycorr);
        context.lineTo(xs[0], ys[1] > ys[0] ? ys[1] - Link.CR : ys[1] + Link.CR);
        context.quadraticCurveTo(xs[0], ys[1], xs[1] > xs[0] ? xs[0] + Link.CR : xs[0] - Link.CR, ys[1]);
        context.lineTo(xs[1], ys[1]);
        break;
    }
    
    if (hitX) {
      if (context.isPointInStroke(hitX, hitY))
        return true;
    }
    else {
      context.stroke();
    }
  };
  
  Link.prototype.drawConnectorArrow = function(context, hitX, hitY) {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    var p = 12;
    var slope;
    var x, y;
    if (type == Link.LINK_TYPES.STRAIGHT) {
      var p2 = xs.length - 1;
      var p1 = p2 - 1;
      x = xs[p2];
      y = ys[p2];
      slope = this.getSlope(xs[p1], ys[p1], xs[p2], ys[p2]);
    } 
    else if (xs.length == 2) {  
      // auto ELBOW/ELBOWH/ELBOWV type
      switch (this.getAutoElbowLinkType()) {
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_V:
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VHV:                   
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HV:
          x = xs[1];
          y = ys[1] > ys[0] ? ys[1] + Link.GAP : ys[1] - Link.GAP;
          slope = ys[1] > ys[0] ? Math.PI/2 : Math.PI*1.5;
          break;
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_H:
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HVH:
        case Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VH:
          x = xs[1] > xs[0] ? xs[1] + Link.GAP : xs[1] - Link.GAP;
          y = ys[1];
          slope = xs[1] > xs[0] ? 0 : Math.PI;
          break;
      }                
    } 
    else {  
      // ELBOW/ELBOWH/ELBOWV, control points > 2
      var k = xs.length - 1;
      if (xs[k] == xs[k-1] && (ys[k] != ys[k-1] || ys[k-1] == ys[k-2])) {
        // verticle arrow
        x = xs[k];
        y = ys[k] > ys[k-1] ? ys[k] + Link.GAP : ys[k] - Link.GAP;
        slope = ys[k] > ys[k-1] ? Math.PI/2 : Math.PI*1.5;              
      } 
      else {
        x = xs[k] > xs[k-1] ? xs[k] + Link.GAP : xs[k] - Link.GAP;
        y = ys[k];
        slope = xs[k] > xs[k-1] ? 0 : Math.PI;
      }
    }
    // convert point and slope to polygon
    var dl = slope - 2.7052;  // 25 degrees
    var dr = slope + 2.7052;  // 25 degrees
    
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(Math.round(Math.cos(dl)*p + x), Math.round(Math.sin(dl)*p + y));
    context.lineTo(Math.round(Math.cos(dr)*p + x), Math.round(Math.sin(dr)*p + y));
    if (hitX) {
      return context.isPointInStroke(hitX, hitY);
    }
    else {
      context.fill();
      context.stroke();
    }
    
  };
  
  Link.prototype.getAutoElbowLinkType = function() {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    
    if (type == Link.ELBOWH) {
      if (xs[0] == xs[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_V; 
      } 
      else if (ys[0] == ys[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_H;
      } 
      else if (Math.abs(this.to.display.x - this.from.display.x) > Link.ELBOW_VH_THRESHOLD) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HVH;
      }
      else {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HV;
      }
    } 
    else if (type === Link.ELBOWV) {
      if (xs[0] == xs[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_V; 
      }
      else if (ys[0] == ys[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_H;
      }
      else if (Math.abs(this.to.display.y - this.from.display.y) > Link.ELBOW_VH_THRESHOLD) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VHV;
      }
      else {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VH;
      }
    } 
    else {
      if (xs[0] == xs[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_V; 
      }
      else if (ys[0] == ys[1]) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_H;
      } 
      else if (Math.abs(this.to.display.x - this.from.display.x) < Math.abs(this.to.display.y - this.from.display.y) * Link.ELBOW_THRESHOLD) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_VHV;
      } 
      else if (Math.abs(this.to.display.y - this.from.display.y) < Math.abs(this.to.display.x - this.from.display.x) * Link.ELBOW_THRESHOLD) {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HVH;
      } 
      else {
        return Link.AUTO_ELBOW_LINK_TYPES.AUTOLINK_HV;
      }
    }
  };

  Link.prototype.recalc = function(step) {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    var lx = this.display.lx;
    var ly = this.display.ly;
  
    var n = xs.length;
    var i, k;
    // remember relative label position
    var labelSlope = this.getSlope(xs[0], ys[0], lx, ly) - this.getSlope(xs[0], ys[0], xs[n-1], ys[n-1]);
    var labelDist = this.getDist(xs[0], ys[0], xs[n-1], ys[n-1]);
    if (labelDist < 5.0) 
      labelDist = 0.5;
    else 
      labelDist = this.getDist(xs[0], ys[0], lx, ly) / labelDist;
    
    if (type == Link.LINK_TYPES.STRAIGHT) {
      if (n == 2) {
        this.calc();
      }
      else {
        if (step == this.from) {
          if (xs[1] > step.display.x + step.display.w + Link.GAP) 
            xs[0] = step.display.x + step.display.w + Link.GAP;
          else if (xs[1] < step.display.x - Link.GAP)
            xs[0] = step.display.x - Link.GAP;
          if (ys[1] > step.display.y + step.display.h + Link.GAP) 
            ys[0] = step.display.y + step.display.h + Link.GAP;
          else if (ys[1] < step.display.y - Link.GAP)
            ys[0] = step.display.y - Link.GAP;
        } 
        else {
          k = n - 1;
          if (xs[k-1] > step.display.x + step.display.w + Link.GAP)
            xs[k] = step.display.x + step.display.w + Link.GAP;
          else if (xs[k-1] < step.display.x - Link.GAP)
            xs[k] = step.display.x - Link.GAP;
          if (ys[k-1] > step.display.y + step.display.h + Link.GAP) 
            ys[k] = step.display.y + step.display.h + Link.GAP;
          else if (ys[k-1] < step.display.y - Link.GAP)
            ys[k] = step.display.y - Link.GAP;
        }
      }
    } 
    else if (n == 2) {
      // automatic ELBOW, ELBOWH, ELBOWV
      this.calcAutoElbow();
    } 
    else {
      // controlled ELBOW, ELBOWH, ELBOWV
      var wasHorizontal = !this.isAnchorHorizontal(0);
      var horizontalFirst = (Math.abs(this.from.display.x - this.to.display.x) >= Math.abs(this.from.display.y - this.to.display.y));
      if (type == Link.LINK_TYPES.ELBOW && wasHorizontal != horizontalFirst) {
        this.calc();
      } 
      else if (step == this.from) {
        if (xs[1] > step.display.x + step.display.w)
          xs[0] = step.display.x + step.display.w + Link.GAP;
        else if (xs[1] < step.display.x) 
          xs[0] = step.display.x - Link.GAP;
        else 
          xs[0] = xs[1];
            
        if (ys[1] > step.display.y + step.display.h) 
          ys[0] = step.display.y + step.display.h + Link.GAP;
        else if (ys[1] < step.display.y) 
          ys[0] = step.display.y - Link.GAP;
        else ys[0] = ys[1];
            
        if (wasHorizontal) 
          ys[1] = ys[0];
        else 
          xs[1] = xs[0];
      }
      else {
        k = n - 1;
        if (xs[k-1] > step.display.x + step.display.w)
          xs[k] = step.display.x + step.display.w + Link.GAP;
        else if (xs[k-1] < step.display.x) 
          xs[k] = step.display.x - Link.GAP;
        else 
          xs[k] = xs[k-1];
        
        if (ys[k-1] > step.display.y + step.display.h) 
          ys[k] = step.display.y + step.display.h + Link.GAP;
        else if (ys[k-1] < step.display.y) 
          ys[k] = step.display.y - Link.GAP;
        else 
          ys[k] = ys[k-1];
            
        if ((wasHorizontal && n % 2 === 0) || (!wasHorizontal && n % 2 !== 0))
          ys[k-1] = ys[k];
        else 
          xs[k-1] = xs[k];
      }
    }
    
    // label position
    labelSlope = this.getSlope(xs[0], ys[0], xs[n-1], ys[n-1]) + labelSlope;
    labelDist = this.getDist(xs[0], ys[0], xs[n-1], ys[n-1]) * labelDist;
    this.display.lx = Math.round(xs[0] + Math.cos(labelSlope) * labelDist);
    this.display.ly = Math.round(ys[0] + Math.sin(labelSlope) * labelDist);

    this.setDisplay(this.display);
  };

  Link.prototype.calc = function() {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    var x1 = this.from.display.x;
    var y1 = this.from.display.y;
    var w1 = this.from.display.w;
    var h1 = this.from.display.h;
    var x2 = this.to.display.x;
    var y2 = this.to.display.y;
    var w2 = this.to.display.w;
    var h2 = this.to.display.h;
    
    var n = xs.length < 2 ? 2 : xs.length;
    var i;
    
    if (type == Link.LINK_TYPES.STRAIGHT) {
      xs = this.display.xs = [];
      ys = this.display.ys = [];
      for (i = 0; i < n; i++) {
        xs.push(0);
        ys.push(0);
      }
        
      if (Math.abs(x1 - x2) >= Math.abs(y1 - y2)) {
        // more of a horizontal link
        xs[0] = (x1 <= x2) ? (x1 + w1) : x1;
        ys[0] = y1 + h1 / 2;
        xs[n-1] = (x1 <= x2) ? x2 : (x2 + w2);
        ys[n-1] = y2 + h2 / 2;
        for (i = 1; i < n - 1; i++) {
          if (i % 2 !== 0) {
            ys[i] = ys[i-1];
            xs[i] = (xs[n-1] -xs[0]) * ((i + 1) / 2) / (n / 2) + xs[0];
          } 
          else {
            xs[i] = xs[i-1];
            ys[i] = (ys[n-1] - ys[0]) * ((i + 1) / 2) / ((n - 1) / 2) + ys[0];
          }
        }
      }
      else {
        // more of a vertical link
        xs[0] = x1 + w1 / 2;
        ys[0] = (y1 <= y2) ? (y1 + h1) : y1;
        xs[n-1] = x2 + w2 / 2;
        ys[n-1] = (y1 <= y2) ? y2 : (y2 + h2);
        for (i = 1; i < n - 1; i++) {
          if (i % 2 !== 0) {
            xs[i] = xs[i-1];
            ys[i] = (ys[n-1] - ys[0]) * ((i + 1) / 2) / (n / 2) + ys[0];
          } 
          else {
            ys[i] = ys[i-1];
            xs[i] = (xs[n-1] - xs[0]) * (i / 2) / ((n - 1) / 2) + xs[0];
          }
        }
      }
    }
    else if (n == 2) {
      // auto ELBOW, ELBOWH, ELBOWV 
      xs = this.display.xs = [0, 0];
      ys = this.display.xs = [0, 0];
      this.calcAutoElbow();
    } 
    else {
      // ELBOW, ELBOWH, ELBOWV with middle control points
      var horizontalFirst = type == Link.LINK_TYPES.ELBOWH || (type == Link.LINK_TYPES.ELBOWH && Math.abs(x1 - x2) >= Math.abs(y1 - y2));
      var evenN = n % 2 === 0;
      var horizontalLast = (horizontalFirst && evenN) || (!horizontalFirst && !evenN);
      xs = this.display.xs = [];
      ys = this.display.ys = [];
      for (i = 0; i < n; i++) {
        xs.push(0);
        ys.push(0);
      }
      if (horizontalFirst) {
        xs[0] = (x1 <= x2) ? (x1 + w1) : x1;
        ys[0] = y1 + h1 / 2;
      } 
      else {
        xs[0] = x1 + w1 / 2;
        ys[0] = (y1 <= y2) ? (y1 + h1) : y1;
      }
      if (horizontalLast) {
        xs[n-1] = (x2 <= x1) ? (x2 + w2) : x2;
        ys[n-1] = y2 + h2 / 2;
      } 
      else {
        xs[n-1] = x2 + w2 / 2;
        ys[n-1] = (y2 <= y1) ? (y2 + h2) : y2;
      }
      if (horizontalFirst) {
        for (i = 1; i < n - 1; i++) {
          if (i % 2 !== 0) {
            ys[i] = ys[i-1];
            xs[i] = (xs[n-1] - xs[0]) * ((i + 1) / 2) / (n / 2) + xs[0];
          } 
          else {
            xs[i] = xs[i-1];
            ys[i] = (ys[n-1] - ys[0]) * ((i + 1) / 2) / ((n - 1) / 2) + ys[0];
          }
        }
      } 
      else {
        for (i = 1; i < n - 1; i++) {
          if (i % 2 !== 0) {
            xs[i] = xs[i-1];
            ys[i] = (ys[n-1] - ys[0]) * ((i + 1) / 2) / (n / 2) + ys[0];
          } 
          else {
            ys[i] = ys[i-1];
            xs[i] = (xs[n-1] - xs[0]) * (i / 2) / ((n - 1) / 2) + xs[0];
          }
        }
      }
    }
    this.calcLabel();
    this.setDisplay(this.display);
  };
  
  Link.prototype.isAnchorHorizontal = function(anchor) {
    var p = anchor - 1;
    var n = anchor + 1;
    if (p >= 0 && this.display.xs[p] != this.display.xs[anchor] && this.display.ys[p] == this.display.ys[anchor]) {
      return true;
    } 
    else if (n < this.display.xs.length && this.display.xs[n] == this.display.xs[anchor] && this.display.ys[n] != this.display.ys[anchor]) {
      return true;
    } 
    else {
      return false;
    }
  };
  
  Link.prototype.calcLabel = function() {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
  
    var x1 = this.from.display.x;
    var y1 = this.from.display.y;
    var x2 = this.to.display.x;
    
    var n = xs.length;

    if (type == Link.LINK_TYPES.STRAIGHT) {
      this.display.lx = (xs[0] + xs[n-1]) / 2;
      this.display.ly = (ys[0] + ys[n-1]) / 2;
    } 
    else if (n == 2) {
      // auto ELBOW, ELBOWH, ELBOWV 
      this.display.lx = (xs[0] + xs[n-1]) / 2;
      this.display.ly = (ys[0] + ys[n-1]) / 2;
    } 
    else {    
      // ELBOW, ELBOWH, ELBOWV with middle control points
      var horizontalFirst = ys[0] == ys[1];
      if (n <= 3) {
        if (horizontalFirst) {
          this.display.lx = (x1 + x2) / 2 - 40;
          this.display.ly = ys[0] - 4;
        } 
        else {
          this.display.lx = xs[0] + 2;
          this.display.ly = (ys[0] + ys[1]) / 2;
        }
      } 
      else {
        if (horizontalFirst) {
          this.display.lx = (x1 <= x2) ? (xs[(n-1) / 2] + 2) : (xs[(n-1)/2 + 1] + 2);
          this.display.ly = ys[n/2] - 4;
        } 
        else {
          this.display.lx = (x1 <= x2) ? xs[n/2 - 1] : xs[n/2];
          this.display.ly = ys[n/2 - 1] - 4;
        }
      }
    }
  };
  
  Link.prototype.calcAutoElbow = function() {
    var type = this.display.type;
    var xs = this.display.xs;
    var ys = this.display.ys;
    
    if (this.to.display.x + this.to.display.w >= this.from.display.x && this.to.display.x <= this.from.display.x + this.from.display.w) {
      // V
      xs[0] = xs[1] = (Math.max(this.from.display.x, this.to.display.x) + Math.min(this.from.display.x + this.from.display.w, this.to.display.x + this.to.display.w)) / 2;
      if (this.to.display.y > this.from.display.y) {
        ys[0] = this.from.display.y + this.from.display.h + Link.GAP;
        ys[1] = this.to.display.y - Link.GAP;
      } 
      else {
        ys[0] = this.from.display.y - Link.GAP;
        ys[1] = this.to.display.y + this.to.display.h + Link.GAP;
      }
    } 
    else if (this.to.display.y + this.to.display.h>= this.from.display.y && this.to.display.y <= this.from.display.y + this.from.display.h) {
      // H
      ys[0] = ys[1] = (Math.max(this.from.display.y, this.to.display.y) + Math.min(this.from.display.y + this.from.display.h, this.to.display.y + this.to.display.h)) / 2;
      if (this.to.display.x > this.from.display.x) {
          xs[0] = this.from.display.x + this.from.display.w + Link.GAP;
          xs[1] = this.to.display.x - Link.GAP;
      }
      else {
          xs[0] = this.from.display.x - Link.GAP;
          xs[1] = this.to.display.x + this.to.display.w + Link.GAP;
      }
    }
    else if ((type == Link.LINK_TYPES.ELBOW && Math.abs(this.to.display.x - this.from.display.x) < Math.abs(this.to.display.y - this.from.display.y) * Link.ELBOW_THRESHOLD) ||
          (type == Link.LINK_TYPES.ELBOWV && Math.abs(this.to.display.y - this.from.display.y) > Link.ELBOW_VH_THRESHOLD)) {
      // VHV
      xs[0] = this.from.display.x + this.from.display.w / 2;
      xs[1] = this.to.display.x + this.to.display.w / 2;
      if (this.to.display.y > this.from.display.y) {
        ys[0] = this.from.display.y + this.from.display.h + Link.GAP;
        ys[1] = this.to.display.y - Link.GAP;
      } 
      else {
        ys[0] = this.from.display.y - Link.GAP;
        ys[1] = this.to.display.y + this.to.display.h + Link.GAP;
      }
    } 
    else if ((type == Link.LINK_TYPES.ELBOW && Math.abs(this.to.display.y - this.from.display.y) < Math.abs(this.to.display.x - this.from.display.x) * Link.ELBOW_THRESHOLD) ||
          (type == Link.LINK_TYPES.ELBOWH && Math.abs(this.to.display.x - this.from.display.x) > Link.ELBOW_VH_THRESHOLD)) {
      // HVH
      ys[0] = this.from.display.y + this.from.display.h / 2;
      ys[1] = this.to.display.y + this.to.display.h / 2;
      if (this.to.display.x > this.from.display.x) {
        xs[0] = this.from.display.x + this.from.display.w + Link.GAP;
        xs[1] = this.to.display.x - Link.GAP;
      } 
      else {
        xs[0] = this.from.display.x - Link.GAP;
        xs[1] = this.to.display.x + this.to.display.w + Link.GAP;
      }
    } 
    else if (type == Link.LINK_TYPES.ELBOWV) {
      // VH
      if (this.to.display.y > this.from.display.y)
        ys[0] = this.from.display.y + this.from.display.h + Link.GAP;
      else 
        ys[0] = this.from.display.y - Link.GAP;
      xs[0] = this.from.display.x + this.from.display.w / 2;
      ys[1] = this.to.display.y + this.to.display.h / 2;
      if (this.to.display.x > this.from.display.x) 
        xs[1] = this.to.display.x - Link.GAP;
      else 
        xs[1] = this.to.display.x + this.to.display.w + Link.GAP;
    } 
    else {
      // HV
      if (this.to.display.x > this.from.display.x)
        xs[0] = this.from.display.x + this.from.display.w + Link.GAP;
      else 
        xs[0] = this.from.display.x - Link.GAP;
      ys[0] = this.from.display.y + this.from.display.h / 2;
      xs[1] = this.to.display.x + this.to.display.w / 2;
      if (this.to.display.y > this.from.display.y)
        ys[1] = this.to.display.y - Link.GAP;
      else 
        ys[1] = this.to.display.y + this.to.display.h + Link.GAP;
    }
  };
  
  // in polar degrees
  Link.prototype.getSlope = function(x1, y1, x2, y2) {
    var slope;
    if (x1 == x2) 
      slope = (y1 < y2) ? Math.PI / 2 : -Math.PI / 2;
    else
      slope = Math.atan(y2 - y1)/(x2 - x1);
    if (x1 > x2) {
        if (slope > 0)
          slope -= Math.PI;
        else 
          slope += Math.PI;
    }
    return slope;
  };
  
  Link.prototype.getDist = function(x1, y1, x2, y2) {
    return Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
  };
  
  Link.prototype.select = function() {
    var context = this.diagram.context;
    context.fillStyle = DC.ANCHOR_COLOR;
    for (var i = 0; i < this.display.xs.length; i++) {
      var x = this.display.xs[i];
      var y = this.display.ys[i];
      context.fillRect(x - DC.ANCHOR_W, y - DC.ANCHOR_W, DC.ANCHOR_W * 2, DC.ANCHOR_W * 2);
    }
    if (this.label)
      this.label.select();
    context.fillStyle = DC.DEFAULT_COLOR;
  };

  Link.prototype.isHover = function(x, y) {
    return (this.label && this.label.isHover(x, y)) || this.drawConnector(x, y);
  };
  
  Link.prototype.getAnchor = function(x, y) {
    for (var i = 0; i < this.display.xs.length; i++) {
      var cx = this.display.xs[i];
      var cy = this.display.ys[i];
      if (Math.abs(cx - x) <= DC.ANCHOR_HIT_W && Math.abs(cy - y) <= DC.ANCHOR_HIT_W)
        return i;
    }
    return -1;
  };
  
  Link.prototype.move = function(deltaX, deltaY) {
    var display = {
      type: this.display.type,
      lx: this.display.lx + deltaX,
      ly: this.display.ly + deltaY,
      xs: [], 
      ys: []
    };
    if (this.display.xs) {
      this.display.xs.forEach(function(x) {
        display.xs.push(x + deltaX);
      });
    }
    if (this.display.ys) {
      this.display.ys.forEach(function(y) {
        display.ys.push(y + deltaY);
      });
    }
    this.setDisplay(display);
  };
  
  Link.prototype.moveAnchor = function(anchor, deltaX, deltaY) {
    var display = {
      type: this.display.type,
      lx: this.display.lx,
      ly: this.display.ly,
      xs: [], 
      ys: []
    };
    for (var i = 0; i < this.display.xs.length; i++) {
      if (i == anchor) {
        display.xs.push(this.display.xs[i] + deltaX);
        display.ys.push(this.display.ys[i] + deltaY);
      }
      else {
        display.xs.push(this.display.xs[i]);
        display.ys.push(this.display.ys[i]);
      }
    }

    if (display.type.startsWith('Elbow')) {
      if (this.isAnchorHorizontal(anchor)) {
        if (anchor > 0) 
          display.ys[anchor - 1] = this.display.ys[anchor] + deltaY;
        if (anchor < display.xs.length - 1)
          display.xs[anchor + 1] = this.display.xs[anchor] + deltaX;
      }
      else {
        if (anchor > 0) 
          display.xs[anchor - 1] = this.display.xs[anchor] + deltaX;
        if (anchor < display.xs.length - 1) 
          display.ys[anchor + 1] = this.display.ys[anchor] + deltaY;
      }
    }

    // TODO: update arrows
    this.setDisplay(display);
  };
  
  Link.prototype.moveLabel = function(deltaX, deltaY) {
    this.setDisplay({
      type: this.display.type,
      lx: this.display.lx + deltaX,
      ly: this.display.ly + deltaY,
      xs: this.display.xs, 
      ys: this.display.ys
    });
  };
  
  return Link;
}]);

// source: web/js/ui/list.js
var listMod = angular.module('mdwList', ['mdw']);

listMod.controller('MdwListController', ['$scope', '$http', '$location', 'mdw', 'util', 'EXCEL_DOWNLOAD',
                                             function($scope, $http, $location, mdw, util, EXCEL_DOWNLOAD) {
  $scope.init = function() {
    
    $scope.$watch('listFilter', function(aft, bef) {
      $scope.items = [];
      $scope.listModel[$scope.listItems] = $scope.items;
      $scope.listModel.count = 0;
      $scope.listModel.total = 0;
      $scope.listModel.selected = null;
      $scope.getNextPage();
    }, true);
    
  };

  // TODO hardcoded
  $scope.max = 50;
  $scope.scrollBuffer = 5; // getting this close forces retrieval
  $scope.maxDownloadItems = 10000;
  
  $scope.items = [];
  $scope.busy = false;
  
  $scope.getNextPage = function(callback) {
    if (!$scope.busy) {
      $scope.busy = true;
      
      // retrieve the item list
      $scope.url = mdw.roots.services + $scope.serviceUrl + '?app=mdw-admin' + '&start=' + $scope.items.length + '&max=' + $scope.max;
      var urlParams = util.urlParams();
      if (util.isEmpty(urlParams)) {
        $scope.url += $scope.getFilterQuery();
      }
      else {
        util.getProperties(urlParams).forEach(function(key) {
          $scope.url += '&' + key + '=' + urlParams[key];
        });
      }
      
      $http.get($scope.url).error(function(data, status) {
        console.log('HTTP ' + status + ': ' + $scope.url);
      }).success(function(data, status, headers, config) {
        $scope.$emit('page-retrieved', data);
        $scope.listModel = data;
        var newItems = data[$scope.listItems];
        $scope.items = $scope.items.concat(newItems);
        $scope.listModel[$scope.listItems] = $scope.items;
        
        $scope.listModel.reload = function(callback) {
          $scope.items = [];
          $scope.getNextPage(callback);
        };
        
        if ($scope.styleClass == 'mdw-checklist') {
          $scope.listModel.selectedState = { all: false };
          $scope.listModel.toggleAll = function() {
            $scope.items.forEach(function(item) {
              item.selected = $scope.listModel.selectedState.all;
            });
          };
          $scope.listModel.notAllSelected = function() {
            $scope.listModel.selectedState.all = false;
          };
          $scope.listModel.getSelectedItems = function() {
            var selected = [];
            if ($scope.items) {
              $scope.items.forEach(function(item) {
                if (item.selected)
                  selected.push(item);
              });
            }
            return selected;
          };
        }
        
        $scope.listModel.downloadExcel = function() {
          if ($scope.listModel.total > $scope.maxDownloadItems) {
            window.alert('Cannot download more than ' + $scope.maxDownloadItems + ' items.  Please narrow results by filtering.');
          }
          else {
            var downloadUrl = mdw.roots.services + $scope.serviceUrl + '?app=mdw-admin&start=0&max=-1';
            downloadUrl += $scope.getFilterQuery() + '&' + EXCEL_DOWNLOAD;
            window.location = downloadUrl;
          }
        };    
        $scope.busy = false;

        if (callback) {
          callback($scope.listModel);
        }
      });
    }
  };
  
  $scope.getFilterQuery = function() {
    var query = '';
    for (var key in $scope.listFilter) {
      if ($scope.listFilter.hasOwnProperty(key)) {
        var val = $scope.listFilter[key];
        if (val !== null && typeof(val) != "undefined") {
          if (val instanceof Date) 
            val = util.serviceDate(val);
          query += '&' + key + '=' + val;
        }
      }
    }
    return query;
  };
  
  $scope.hasMore = function() {
    return $scope.items.length === 0 || $scope.items.length < $scope.listModel.total;
  };
  
}]);

listMod.directive('mdwList', function() {
  return {
    restrict: 'E',
    templateUrl: 'ui/list.html',
    scope: {
      styleClass: '@class',
      serviceUrl: '@mdwListService',
      listModel: '=mdwListModel',
      listFilter: '=mdwListFilter',
      listItems: '@mdwListItems',
      itemTemplate: '@mdwListItem'
    },
    controller: 'MdwListController',
    controllerAs: 'mdwList',
    link: function link(scope, elem, attrs, ctrls) {
      scope.init();
    }
  };
});
// source: web/js/ui/marquee.js
var marqueeMod = angular.module('mdwMarquee', ['mdw']);

marqueeMod.factory('Marquee', ['$document', 'mdw', 'util', 'Shape', 'DC',
                         function($document, mdw, util, Shape, DC) {
  var Marquee = function(diagram) {
    Shape.call(this, diagram);
    this.diagram = diagram;
    this.workflowItem = { attributes: { WORK_DISPLAY_INFO: {x: 0, y: 0, w: 0, h: 0} } }; // dummy to hold attrs
    this.isMarquee = true;
  };
  
  Marquee.prototype = new Shape();
  
  Marquee.BOX_OUTLINE_COLOR = 'cyan';
  Marquee.BOX_ROUNDING_RADIUS = 2;

  Marquee.prototype.draw = function() {
    this.diagram.rect(this.display.x, this.display.y, this.display.w, this.display.h, Marquee.BOX_OUTLINE_COLOR, null, Marquee.BOX_ROUNDING_RADIUS);
  };
  
  Marquee.prototype.prepareDisplay = function() {
    this.display = this.getDisplay();
    return this.display;
  };
  
  Marquee.prototype.start = function(x, y) {
    this.setDisplayAttr(x, y, 2, 2);
    this.display = this.getDisplay();
  };
  
  Marquee.prototype.resize = function(x, y, deltaX, deltaY) {
    var newX = deltaX > 0 ? x : x + deltaX;
    if (newX < 0)
      newX = 0;
    var newY = deltaY > 0 ? y : y + deltaY;
    if (newY < 0)
      newY = 0;
    var newW = deltaX > 0 ? deltaX : -deltaX;
    var newH = deltaY > 0 ? deltaY : -deltaY;
    
    this.setDisplayAttr(newX, newY, newW, newH);
  };
  
  Marquee.prototype.getAnchor = function(x, y) {
    return -1;
  };
  
  Marquee.prototype.getSelectObjs = function() {
    var selObjs = [];
    for (let i = 0; i < this.diagram.steps.length; i++) {
      var step = this.diagram.steps[i];
      if (this.isContained(step))
        selObjs.push(step);
    }
    for (let i = 0; i < this.diagram.subflows.length; i++) {
      var subflow = this.diagram.subflows[i];
      if (this.isContained(subflow))
        selObjs.push(subflow);
    }
    for (let i = 0; i < this.diagram.notes.length; i++) {
      var note = this.diagram.notes[i];
      if (this.isContained(note))
        selObjs.push(note);
    }
    return selObjs;
  };
  
  Marquee.prototype.isContained = function(shape) {
    return shape.display.x >= this.display.x && shape.display.y > this.display.y &&
        shape.display.x + shape.display.w <= this.display.x + this.display.w && 
        shape.display.y + shape.display.h <= this.display.y + this.display.h;
  };
  
  return Marquee;
}]);
// source: web/js/ui/note.js
var noteMod = angular.module('mdwNote', ['mdw']);

noteMod.factory('Note', ['$document', 'mdw', 'util', 'Shape', 'DC',
                         function($document, mdw, util, Shape, DC) {
  var Note = function(diagram, textNote) {
    Shape.call(this, diagram, textNote);
    this.diagram = diagram;
    this.textNote = textNote;
    this.workflowType = 'textNote';
    this.isNote = true;
  };
  
  Note.prototype = new Shape();
  
  Note.BOX_FILL_COLOR = '#ffc';
  Note.BOX_OUTLINE_COLOR = 'gray';
  Note.BOX_ROUNDING_RADIUS = 2;
  Note.FONT_SIZE= 13;
  Note.FONT= '13px monospace';

  Note.prototype.draw = function() {
    this.diagram.rect(this.display.x, this.display.y, this.display.w, this.display.h, Note.BOX_OUTLINE_COLOR, Note.BOX_FILL_COLOR, Note.BOX_ROUNDING_RADIUS);
    if (this.textNote.content) {
      var lines = this.textNote.content.getLines();
      this.diagram.context.font = Note.FONT;
      for (var i = 0; i < lines.length; i++) {
        this.diagram.context.fillText(lines[i], this.display.x + 4, this.display.y + 2 + Note.FONT_SIZE * (i + 1));
      }
    }
  };
  
  Note.prototype.prepareDisplay = function() {
    var maxDisplay = { w: 0, h: 0 };
    this.display = this.getDisplay();
    
    // boundaries
    if (this.display.x + this.display.w > maxDisplay.w)
      maxDisplay.w = this.display.x + this.display.w;
    if (this.display.y + this.display.h > maxDisplay.h)
      maxDisplay.h = this.display.y + this.display.h;
    
    return maxDisplay;
  };
  
  Note.prototype.move = function(deltaX, deltaY) {
    var x = this.display.x + deltaX;
    var y = this.display.y + deltaY;
    this.setDisplayAttr(x, y, this.display.w, this.display.h);
    return true;
  };
  
  Note.prototype.resize = function(x, y, deltaX, deltaY) {
    var display = this.resizeDisplay(x, y, deltaX, deltaY, Shape.MIN_SIZE);
    this.setDisplayAttr(display.x, display.y, display.w, display.h);
  };
  
  return Note;
}]);
// source: web/js/ui/panel.js
var panelMod = angular.module('mdwPanel', ['mdw']);

// device-specific wrap
panelMod.directive('mdwPanelCollapse', [function() {
  return {
    restrict: 'E',
    templateUrl: 'ui/panel-collapse.html',
    scope: {
      isCollapsed: '=mdwCollapsed'
    }
  };
}]);

// source: web/js/ui/shape.js
var shapeMod = angular.module('mdwShape', ['mdw']);

// prototype for rectangular diagram elements
shapeMod.factory('Shape', ['mdw', 'util', 'DC',
                         function(mdw, util, DC) {
  
  var Shape = function(diagram, workflowItem) {
    this.diagram = diagram;
    this.workflowItem = workflowItem;
  };
  
  Shape.MIN_SIZE = 4;
  
  // get a display object from an attribute value
  Shape.prototype.getDisplay = function() {
    var displayAttr = this.workflowItem.attributes.WORK_DISPLAY_INFO;
    var display = {};
    if (displayAttr) {
      var vals = displayAttr.split(',');
      vals.forEach(function(val) {
        if (val.startsWith('x='))
          display.x = parseInt(val.substring(2));
        else if (val.startsWith('y='))
          display.y = parseInt(val.substring(2));
        else if (val.startsWith('w='))
          display.w = parseInt(val.substring(2));
        else if (val.startsWith('h='))
          display.h = parseInt(val.substring(2));
      });
    }
    return display;
  };

  Shape.prototype.setDisplayAttr = function(x, y, w, h) {
    var attr = 'x=' + x + ',y=' + y;
    if (w)
      attr += ',w=' + w + ',h=' + h;
    this.workflowItem.attributes.WORK_DISPLAY_INFO = attr;
  };
  
  Shape.prototype.getAttr = function(display) {
    var attr = 'x=' + display.x + ',y=' + display.y;
    if (display.w)
      attr += ',w=' + display.w + ',h=' + display.h;
    return attr;
  };
  
  Shape.prototype.isHover = function(x, y) {
    return x >= this.display.x && x <= this.display.x + this.display.w &&
        y >= this.display.y && y <= this.display.y + this.display.h;
  };
  
  Shape.prototype.select = function() {
    var display = this.display;
    var context = this.diagram.context;
    context.fillStyle = DC.ANCHOR_COLOR;
    var s = DC.ANCHOR_W;
    context.fillRect(display.x - s, display.y - s, s * 2, s * 2);
    context.fillRect(display.x + display.w - s, display.y - s, s * 2, s * 2);
    context.fillRect(display.x + display.w - 2, display.y + display.h - s, s * 2, s * 2);
    context.fillRect(display.x - 2, display.y + display.h - s, s * 2, s * 2);
    context.fillStyle = DC.DEFAULT_COLOR;
  };
  
  Shape.prototype.getAnchor = function(x, y) {
    if (Math.abs(this.display.x - x) <= DC.ANCHOR_HIT_W && Math.abs(this.display.y - y) <= DC.ANCHOR_HIT_W)
      return 0;
    else if (Math.abs(this.display.x + this.display.w - x) <= DC.ANCHOR_HIT_W && Math.abs(this.display.y - y) <= DC.ANCHOR_HIT_W)
      return 1;
    else if (Math.abs(this.display.x + this.display.w - x) <= DC.ANCHOR_HIT_W && Math.abs(this.display.y + this.display.h - y) <= DC.ANCHOR_HIT_W)
      return 2;
    else if (Math.abs(this.display.x - x) <= DC.ANCHOR_HIT_W && Math.abs(this.display.y + this.display.h - y) <= DC.ANCHOR_HIT_W)
      return 3;
    else 
      return -1;
  };
  
  Shape.prototype.resizeDisplay = function(x, y, deltaX, deltaY, min, limDisplay) {
    var anchor = this.getAnchor(x, y);
    var display = {x: this.display.x, y: this.display.y, w: this.display.w, h: this.display.h};
    var t1, t2;
    if (anchor === 0) {
      t1 = display.x + display.w;
      t2 = display.y + display.h;
      display.x = x + deltaX;
      display.y = y + deltaY;
      if (t1 - display.x < min)
        display.x = t1 - min;
      if (t2 - display.y < min) 
        display.y = t2 - min;
      display.w = t1 - display.x;
      display.h = t2 - display.y;
    } 
    else if (anchor == 1) {
      t2 = display.y + display.h;
      display.y = y + deltaY;
      if (t2 - display.y < min) 
        display.y = t2 - min;
      display.w = x - (display.x - deltaX);
      if (display.w < min) 
        display.w = min;
      display.h = t2 - display.y;
    } 
    else if (anchor == 2) {
      display.w = x - (display.x - deltaX);
      display.h = y - (display.y - deltaY);
      if (display.w < min) 
        display.w = min;
      if (display.h < min) 
        display.h = min;
    } 
    else if (anchor == 3) {
      t1 = display.x + display.w;
      display.x = x + deltaX;
      if (t1 - display.x < min)
        display.x = t1 - min;
      display.w = t1 - display.x;
      display.h = y - (display.y - deltaY);
      if (display.h < min) 
        display.h = min;
    }
    
    if (limDisplay) {
      if (display.x < limDisplay.x)
        display.x = limDisplay.x;
      if (display.x + display.w > limDisplay.x + limDisplay.w)
        display.w = limDisplay.x + limDisplay.w - display.x;
      if (display.y < limDisplay.y)
        display.y = limDisplay.y;
      if (display.y + display.h > limDisplay.y + limDisplay.h)
        display.h = limDisplay.y + limDisplay.h - display.y;
    }
    
    return display;
  };
  
  
  return Shape;
  
}]);
// source: web/js/ui/step.js
var stepMod = angular.module('mdwStep', ['mdw']);

stepMod.factory('Step', ['mdw', 'util', 'Shape', 'DC', 'WORKFLOW_STATUSES',
                         function(mdw, util, Shape, DC, WORKFLOW_STATUSES) {
  
  var Step = function(diagram, activity) {
    Shape.call(this, diagram, activity);
    this.diagram = diagram;
    this.activity = activity;
    this.workflowType = 'activity';
    this.isStep = true;
  };
  
  Step.prototype = new Shape();
  
  Step.INST_W = 8;
  Step.OLD_INST_W = 4;
  Step.MAX_INSTS = 10;
  Step.MIN_SIZE = 4;
  
  Step.STATUSES = [{status: 'Unknown', color: 'transparent'}].concat(WORKFLOW_STATUSES);
  
  Step.prototype.draw = function() {
    var activity = this.workflowObj = this.activity;
    var shape;
    if (this.implementor.icon && this.implementor.icon.startsWith('shape:'))
      shape = this.implementor.icon.substring(6);
    
    // runtime state first
    if (this.instances) {
      var adj = 0;
      if (shape == 'start' || shape == 'stop')
        adj = 2;
      this.diagram.drawState(this.display, this.instances, !this.diagram.drawBoxes, adj);
    }
    
    if (this.implementor.icon) {
      var yAdjust = -2;
      if (shape) {
        if ('start' == shape) {
          this.diagram.drawOval(this.display.x, this.display.y, this.display.w, this.display.h, 'green', 'white');
        }
        else if ('stop' == shape) {
          this.diagram.drawOval(this.display.x, this.display.y, this.display.w, this.display.h, 'red', 'white');
        }
        else if ('decision' == shape) {
          this.diagram.drawDiamond(this.display.x, this.display.y, this.display.w, this.display.h);
          yAdjust = -8;
        }
        else if ('activity' == shape) {
          this.diagram.roundedRect(this.display.x, this.display.y, this.display.w, this.display.h, DC.BOX_OUTLINE_COLOR);
        }
      }
      else {
        if (this.diagram.drawBoxes)
          this.diagram.roundedRect(this.display.x, this.display.y, this.display.w, this.display.h, DC.BOX_OUTLINE_COLOR);
        var iconSrc = 'asset/' + this.implementor.icon;
        var iconX = this.display.x + this.display.w / 2 - 12;
        var iconY = this.display.y + 5;
        this.diagram.drawImage(iconSrc, iconX, iconY);
        yAdjust = +4; 
      }
    }
    else {
      this.diagram.roundedRect(this.display.x, this.display.y, this.display.w, this.display.h, DC.BOX_OUTLINE_COLOR);
    }

    // title
    var diagram = this.diagram;
    this.title.lines.forEach(function(line) {
      diagram.context.fillText(line.text, line.x, line.y + yAdjust);
    });
    
    // logical id
    this.diagram.context.fillStyle = DC.META_COLOR;
    this.diagram.context.fillText(activity.id, this.display.x + 2, this.display.y - 2);
    this.diagram.context.fillStyle = DC.DEFAULT_COLOR;
    
  };
  
  // sets display/title and returns an object with w and h for required size
  Step.prototype.prepareDisplay = function() {
    var maxDisplay = { w: 0, h: 0};
    var display = this.getDisplay();

    if (display.x + display.w > maxDisplay.w)
      maxDisplay.w = display.x + display.w;
    if (display.y + display.h > maxDisplay.h)
      maxDisplay.h = display.y + display.h;
    
    // step title
    var titleLines = [];
    this.activity.name.getLines().forEach(function(line) {
      titleLines.push({ text: line });
    });
    var title = { text: this.activity.name, lines: titleLines, w: 0, h:0 };
    for (var i = 0; i < title.lines.length; i++) {
      var line = title.lines[i];
      var textMetrics = this.diagram.context.measureText(line.text);
      if (textMetrics.width > title.w)
        title.w = textMetrics.width;
      title.h += DC.DEFAULT_FONT.SIZE;
      line.x = display.x + display.w / 2 - textMetrics.width / 2;
      line.y = display.y + display.h / 2 + DC.DEFAULT_FONT.SIZE * (i + 0.5);
      if (line.x + textMetrics.width > maxDisplay.w)
        maxDisplay.w = line.x + textMetrics.width;
      if (line.y + DC.DEFAULT_FONT.SIZE > maxDisplay.h)
        maxDisplay.h = line.y + DC.DEFAULT_FONT.SIZE;
    }

    this.display = display;
    this.title = title;    
    
    return maxDisplay;
  };
  
  Step.prototype.applyState = function(activityInstances) {
    this.instances = activityInstances;
  };

  Step.prototype.move = function(deltaX, deltaY, limDisplay) {
    var x = this.display.x + deltaX;
    var y = this.display.y + deltaY;
    if (limDisplay) {
      if (x < limDisplay.x)
        x = limDisplay.x;
      else if (x > limDisplay.x + limDisplay.w - this.display.w)
        x = limDisplay.x + limDisplay.w - this.display.w;
      if (y < limDisplay.y)
        y = limDisplay.y;
      else if (y > limDisplay.y + limDisplay.h - this.display.h)
        y = limDisplay.y + limDisplay.h - this.display.h;
    }
    this.setDisplayAttr(x, y, this.display.w, this.display.h);
  };
  
  Step.prototype.resize = function(x, y, deltaX, deltaY, limDisplay) {
    var display = this.resizeDisplay(x, y, deltaX, deltaY, Step.MIN_SIZE, limDisplay);
    this.activity.attributes.WORK_DISPLAY_INFO = this.getAttr(display);
  };
  
  return Step;
    
}]);

// source: web/js/ui/subflow.js
var subflowMod = angular.module('mdwSubflow', ['mdw']);

subflowMod.factory('Subflow', ['$document', 'mdw', 'util', 'Shape', 'DC', 'Step', 'Link',
                                function($document, mdw, util, Shape, DC, Step, Link) {
  var Subflow = function(diagram, subprocess) {
    Shape.call(this, diagram, subprocess);
    this.diagram = diagram;
    this.subprocess = subprocess;
    this.workflowType = 'subprocess';
    this.isSubflow = true;
  };
  
  Subflow.prototype = new Shape();

  Subflow.BOX_OUTLINE_COLOR = '#337ab7';
  Subflow.HIT_WIDTH = 7;
  
  Subflow.prototype.draw = function() {

    // runtime state first
    if (this.instances) {
      this.diagram.drawState(this.display, this.instances, true);
    }
    
    this.diagram.roundedRect(this.display.x, this.display.y, this.display.w, this.display.h, Subflow.BOX_OUTLINE_COLOR);
    this.diagram.context.clearRect(this.title.x - 1, this.title.y, this.title.w + 2, this.title.h);

    this.diagram.context.fillText(this.title.text, this.title.x, this.title.y + DC.DEFAULT_FONT.SIZE);
    this.steps.forEach(function(step) {
      step.draw();
    });
    this.links.forEach(function(link) {
      link.draw();
    });
    
    // logical id
    this.diagram.context.fillStyle = DC.META_COLOR;
    this.diagram.context.fillText('[' + this.subprocess.id + ']', this.display.x + 10, this.display.y + this.display.h + 4);
    this.diagram.context.fillStyle = DC.DEFAULT_COLOR;
  };
  
  Subflow.prototype.prepareDisplay = function() {
    var maxDisplay = { w: 0, h: 0 };
    this.display = this.getDisplay();
    
    // title
    var title = { 
        subflow: this,
        text: this.subprocess.name,
        x: this.display.x + 10, 
        y: this.display.y + 4 - DC.DEFAULT_FONT.SIZE,        
        isHover: function(x, y) {
          var hov = x >= this.x && x <= this.x + this.w &&
              y >= this.y && y <= this.y + this.h;
          if (!hov) {
            var context = subflow.diagram.context;
            var previousLineWidth = context.lineWidth;
            context.lineWidth = Subflow.HIT_WIDTH;
            var display = this.subflow.display; 
            var r = DC.BOX_ROUNDING_RADIUS;
            context.beginPath();
            context.moveTo(display.x + r, display.y);
            context.lineTo(display.x + display.w - r, display.y);
            context.quadraticCurveTo(display.x + display.w, display.y, x + display.w, display.y + r);
            context.lineTo(display.x + display.w, display.y + display.h - r);
            context.quadraticCurveTo(display.x + display.w, display.y + display.h, display.x + display.w - r, display.y + display.h);
            context.lineTo(display.x + r, display.y + display.h);
            context.quadraticCurveTo(display.x, display.y + display.h, display.x, display.y + display.h - r);
            context.lineTo(display.x, display.y + r);
            context.quadraticCurveTo(display.x, display.y, display.x + r, display.y);
            context.closePath();
            hov = context.isPointInStroke(x, y);
            context.lineWidth = previousLineWidth;
          }
          return hov;
        }
    };
    var textMetrics = this.diagram.context.measureText(title.text);
    title.w = textMetrics.width;
    title.h = DC.DEFAULT_FONT.SIZE;
    if (title.x + title.w > maxDisplay.w)
      maxDisplay.w = title.x + title.w;
    if (title.y + title.h > maxDisplay.h)
      maxDisplay.h = title.y + title.h;
    this.title = title;
    
    // boundaries
    if (this.display.x + this.display.w > maxDisplay.w)
      maxDisplay.w = this.display.x + this.display.w;
    if (this.display.y + this.display.h > maxDisplay.h)
      maxDisplay.h = this.display.y + this.display.h;
    
    var subflow = this;
    // just prepare activities -- assume boundaries account for size
    subflow.steps = [];
    if (this.subprocess.activities) {
      this.subprocess.activities.forEach(function(activity) {
        var step = new Step(subflow.diagram, activity);
        step.implementor = subflow.diagram.getImplementor(activity.implementor);
        step.prepareDisplay();
        subflow.steps.push(step);
      });
    }
    subflow.links = [];
    subflow.steps.forEach(function(step) {
      if (step.activity.transitions) {
        step.activity.transitions.forEach(function(transition) {
          var link = new Link(subflow.diagram, transition, step, subflow.getStep(transition.to));
          var display = link.prepareDisplay();
          subflow.links.push(link);
        });
      }
    });
    return maxDisplay;
  };
  
  Subflow.prototype.applyState = function(subprocessInstances) {
    this.instances = subprocessInstances;
    if (this.instances) {
      var subflow = this;
      this.instances.forEach(function(instance) {
        subflow.steps.forEach(function(step) {
          step.applyState(subflow.getActivityInstances(step.activity.id));
        });
      });
    }
  };
  
  Subflow.prototype.getStep = function(activityId) {
    for (var i = 0; i < this.steps.length; i++) {
      if (this.steps[i].activity.id == activityId)
        return this.steps[i];
    }
  };
  
  Subflow.prototype.getLink = function(transitionId) {
    for (var i = 0; i < this.links.length; i++) {
      if (this.links[i].transition.id == transitionId)
        return this.links[i];
    }
  };
  
  Subflow.prototype.getLinks = function(step) {
    var links = [];
    for (var i = 0; i < this.links.length; i++) {
      if (step == this.links[i].to || step == this.links[i].from)
        links.push(this.links[i]);
    }
    return links;
  };
  
  Subflow.prototype.get = function(id) {
    if (id.startsWith('A'))
      return this.getStep(id);
    else if (id.startsWith('T'))
      return this.getLink(id);
  };
  
  Subflow.prototype.getActivityInstances = function(id) {
    if (this.instances) {
      var actInsts = [];
      var mainProcessInstanceId = this.mainProcessInstanceId;
      this.instances.forEach(function(inst) {
        if (inst.activities) {
          var procInstId = mainProcessInstanceId;
          inst.activities.forEach(function(actInst) {
            if ('A' + actInst.activityId == id) {
              actInsts.push(actInst);
              actInst.processInstanceId = procInstId; // needed for subprocess & task instance retrieval
            }
          });
        }
      });
      actInsts.sort(function(a1, a2) {
        return a2.id - a1.id;
      });
      return actInsts;
    }
  };
  
  Subflow.prototype.move = function(deltaX, deltaY) {
    var x = this.display.x + deltaX;
    var y = this.display.y + deltaY;
    this.setDisplayAttr(x, y, this.display.w, this.display.h);
    
    this.steps.forEach(function(step) {
      step.move(deltaX, deltaY);
    });
    this.links.forEach(function(link) {
      link.move(deltaX, deltaY);
    });
  };
  
  Subflow.prototype.resize = function(x, y, deltaX, deltaY) {
    var display = this.resizeDisplay(x, y, deltaX, deltaY, Step.MIN_SIZE);
    this.setDisplayAttr(display.x, display.y, display.w, display.h);
  };
  
  return Subflow;
}]);
// source: web/js/ui/ui-util.js
var uiUtil = angular.module('mdwUtil', ['mdw']);

uiUtil.config(function($httpProvider) {
  $httpProvider.defaults.useXDomain = true;
});

uiUtil.filter('highlight', function($sce) {
  return function(input, lang) {
    if (lang === 'test') {
      lang = 'groovy';
    }
    else if (lang === 'spring' || lang === 'camel') {
      lang = 'xml';
    }
    else if (lang === 'proc' || lang === 'task' || lang === 'impl' || lang === 'evth' || lang == 'pagelet') {
      if (input.trim().startsWith('{'))
        lang = 'json';
      else
        lang = 'xml';
    }
    if (lang && hljs.getLanguage(lang) && input) {
      return hljs.highlight(lang, input.removeCrs()).value;
    }
    else if (input)
      return input.replace(/&/g,'&amp;').replace(/</g,'&lt;');
    else
      return input;
  };
}).filter('unsafe', function($sce) { return $sce.trustAsHtml; });

uiUtil.filter('markdown', function($sce) {
  marked.setOptions({
    highlight: function (code) {
      return hljs.highlightAuto(code).value;
    }
  });
  
  return function(input) {
    if (input)
        return marked(input);
    else
      return input;
  };
}).filter('unsafe', function($sce) { return $sce.trustAsHtml; });

//in case js string does not supply startsWith() and endsWith()
if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function(prefix) {
    return this.indexOf(prefix) === 0;
  };
}
if (typeof String.prototype.endsWith !== 'function') {
  String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}

// TODO: another way for these polyfill functions
// remove DOS/Windows CR characters
String.prototype.removeCrs = function() {
  return this.replace(/\r/g, '');
};
// split into lines (removing CRs first)
String.prototype.getLines = function() {
  return this.removeCrs().split(/\n/);
};
//count lines
String.prototype.lineCount = function() {
  return this.getLines().length;
};
// line numbers
String.prototype.lineNumbers = function() {
  var lines = this.getLines();
  var lineNums = '';
  for (var i = 1; i < lines.length + 1; i++)
    lineNums += i + '\n';
  return lineNums;
};

// source: web/js/ui/values.js
var valuesMod = angular.module('mdwValues', ['mdw']);

valuesMod.controller('MdwValuesController', ['$scope', 'mdw', 'util', 'DOCUMENT_TYPES',
                                             function($scope, mdw, util, DOCUMENT_TYPES) {
  $scope.init = function() {
    $scope.showLines = 2;
    $scope.maxLines = 8;
    
    if (!$scope.dateDisplayFormat)
      $scope.dateDisplayFormat = 'MMM-dd-yyyy';
    
    $scope.$watch('valuesObj', function(valuesObj) {

      // convert object into sorted array
      var valueObj = $scope.values;
      $scope.values = [];
      if (valuesObj && typeof valuesObj === 'object') {
        for (var key in valuesObj) {
          if (valuesObj.hasOwnProperty(key) && !key.startsWith('$')) {
            var val = valuesObj[key];
            val.name = key;
            if (!val.sequence)
              val.sequence = 0;
            val.isDocument = val.type && DOCUMENT_TYPES[val.type];
            val.isException = val.type === 'java.lang.Exception';
            if (val.isDocument) {
              val.showLines = $scope.showLines;
              if (val.value && val.value.lineCount) {
                var lineCount = val.value.lineCount();
                if (lineCount > $scope.maxLines)
                  val.showLines = $scope.maxLines;
                else if (lineCount > $scope.showLines)
                  val.showLines = lineCount;
              }
            }
            else if (val.type === 'java.util.Date' && val.value) {
              // TODO: option to specify date parse format
              val.value = new Date(val.value);
            }
            if (val.display && $scope.editable)
              val.editable = val.display !== 'ReadOnly';
            else
              val.editable = $scope.editable;
            $scope.values.push(val);
          }
        }
        $scope.values.sort(function(val1, val2) {
          var diff = val1.sequence - val2.sequence;
          if (diff === 0) {
            var label1 = val1.label ? val1.label : val1.name;
            var label2 = val2.label ? val2.label : val2.name;
            return label1.localeCompare(label2);
          }
          else {
            return diff;
          }
        });
      }
      
    }, true);
    
    $scope.$watch('editable', function(editable) {
      if ($scope.values) {
        $scope.values.forEach(function(val) {
          val.editable = editable;
        });
      }
    }, true);
  };
  
  $scope.dirty = function(value) {
    value.dirty = true;
  };
  
  $scope.openDatePopup = function(field) {
    $scope.datePopups = {};
    $scope.datePopups[field] = true;
  };
  
  $scope.asException = function(value) {
    return util.asException(value);
  };
}]);

valuesMod.directive('mdwValues', function() {
  return {
    restrict: 'E',
    templateUrl: 'ui/values.html',
    scope: {
      editable: '=mdwValuesEditable',
      valuesObj: '=mdwValuesValues',
      dateDisplayFormat: '@mdwDateDisplay'
    },
    controller: 'MdwValuesController',
    controllerAs: 'mdwValues',
    link: function link(scope, elem, attrs, ctrls) {
      scope.init();
    }
  };
});
// source: web/js/ui/workflow.js
var workflowMod = angular.module('mdwWorkflow', ['mdw', 'drawingConstants']);

workflowMod.controller('MdwWorkflowController', 
    ['$scope', '$http', 'mdw', 'util', 'mdwImplementors', 'Diagram', 'Inspector',
    function($scope, $http, mdw, util, mdwImplementors, Diagram, Inspector) {
  
  $scope.init = function(canvas) {
    if ($scope.serviceBase.endsWith('/'))
      $scope.serviceBase = $scope.serviceBase.substring(0, $scope.serviceBase.length - 1);
    if ($scope.hubBase) {
      if ($scope.hubBase.endsWith('/'))
        $scope.hubBase = $scope.hubBase.substring(0, $scope.hubBase.length - 1);
    }
    else {
      $scope.hubBase = $scope.serviceBase.substring(0, $scope.serviceBase.length - 9);
    }
    
    $scope.canvas = canvas;
    if ($scope.process.$promise) {
      // wait until resolved
      $scope.process.$promise.then(function(data) {
        $scope.process = data;
        $scope.renderProcess();
        $scope.canvas.bind('mousemove', $scope.mouseMove);
        $scope.canvas.bind('mousedown', $scope.mouseDown);
        $scope.canvas.bind('mouseup', $scope.mouseUp);
        $scope.canvas.bind('mouseout', $scope.mouseOut);
        $scope.canvas.bind('dblclick', $scope.mouseDoubleClick);
      }, function(error) {
        mdw.messages = error;
      });
    }
    else {
      $scope.renderProcess();
      $scope.canvas.bind('mousemove', $scope.mouseMove);
      $scope.canvas.bind('mousedown', $scope.mouseDown);
      $scope.canvas.bind('mouseup', $scope.mouseUp);
      $scope.canvas.bind('mouseout', $scope.mouseOut);
      $scope.canvas.bind('dblclick', $scope.mouseDoubleClick);
    }
  };
  
  $scope.dest = function() {
    $scope.canvas.bind('mousemove', $scope.mouseMove);
    $scope.canvas.bind('mousedown', $scope.mouseDown);
    $scope.canvas.bind('mouseup', $scope.mouseUp);
    $scope.canvas.bind('mouseout', $scope.mouseOut);
    $scope.canvas.bind('dblclick', $scope.mouseDoubleClick);
  };
  
  $scope.renderProcess = function() {
    var packageName = $scope.process.packageName;
    var processName = $scope.process.name;
    var processVersion = null; // TODO: version
    var instanceId = $scope.process.id;
    var masterRequestId = $scope.process.masterRequestId;
    var workflowUrl = $scope.serviceBase + '/Workflow/' + packageName + '/' + processName;
    if (processVersion)
      workflowUrl += '/v' + processVersion;
    $http({ method: 'GET', url: workflowUrl })
      .then(function success(response) {
        $scope.process = response.data;
        $scope.process.packageName = packageName; // not returned in JSON
        // restore summary instance data
        $scope.process.id = instanceId;
        $scope.process.masterRequestId = masterRequestId; 
        $scope.implementors = mdwImplementors.get();
        if ($scope.implementors) {
          $scope.doRender();
        }
        else {
          $http({ method: 'GET', url: $scope.serviceBase + '/Implementors' })
          .then(function success(response) {
            $scope.implementors = response.data;
            mdwImplementors.set($scope.implementors);
            $scope.doRender();
          }, function error(response) {
            mdw.messages = response.statusText;
          });
        }
    });
  };
  
  $scope.doRender = function() {
    if ($scope.renderState && $scope.process.id) {
      $http({ method: 'GET', url: $scope.serviceBase + '/Processes/' + $scope.process.id })
        .then(function success(response) {
          $scope.instance = response.data;
          $scope.diagram = new Diagram($scope.canvas[0], $scope.process, $scope.implementors, $scope.instance, $scope.editable, $scope.hubBase);
          $scope.diagram.draw();
        }, function error(response) {
          mdw.messages = response.statusText;
      });
    }
    else {
      $scope.diagram = new Diagram($scope.canvas[0], $scope.process, $scope.implementors, $scope.instance, $scope.editable, $scope.hubBase);
      $scope.diagram.draw();
    }
  };
  
  $scope.down = false;
  $scope.dragging = false;
  $scope.mouseMove = function(e) {
    if ($scope.down && $scope.editable)
      $scope.dragging = true;
    if ($scope.diagram) {
      if ($scope.dragging) {
        if ($scope.diagram.onMouseDrag(e)) {
          $scope.onChange($scope.process);
        }
      }
      else {
        $scope.diagram.onMouseMove(e);
      }
    }
  };
  $scope.mouseDown = function(e) {
    $scope.down = true;
    if ($scope.diagram) {
      $scope.diagram.onMouseDown(e);
      var selObj = $scope.diagram.selection.getSelectObj();
      if (selObj && selObj.isLabel)
        selObj = selObj.owner;
      if (selObj) {
        Inspector.setObj(selObj, !$scope.editable);
      }
      else {
        var bgObj = $scope.diagram.getBackgroundObj(e);
        if (bgObj)
          Inspector.setObj(bgObj, !$scope.editable);
      }
    }
  };
  $scope.mouseUp = function(e) {
    $scope.down = false;
    $scope.dragging = false;
    if ($scope.diagram) {
      $scope.diagram.onMouseUp(e);
    }
  };
  $scope.mouseOut = function(e) {
    $scope.down = false;
    $scope.dragging = false;
    if ($scope.diagram)
      $scope.diagram.onMouseOut(e);
  };
  $scope.mouseDoubleClick = function(e) {
    if ($scope.diagram && $scope.editable) {
      var selObj = $scope.diagram.selection.getSelectObj();
      if (selObj && selObj.isLabel)
        selObj = selObj.owner;
      if (selObj) {
        Inspector.setObj(selObj, true);
      }
    }
  };
}]);

workflowMod.factory('Diagram', 
    ['$document', 'mdw', 'util', 'DC', 'Label', 'Shape', 'Step', 'Link', 'Subflow', 'Note', 'Marquee', 'Selection',
     function($document, mdw, util, DC, Label, Shape, Step, Link, Subflow, Note, Marquee, Selection) {
  var Diagram = function(canvas, process, implementors, instance, editable, imgBase) {
    Shape.call(this, this, process);
    this.canvas = canvas;
    this.process = process;
    this.implementors = implementors;
    this.instance = instance;
    this.editable = editable;
    this.imgBase = imgBase;
    this.workflowType = 'process';
    this.isDiagram = true;
    this.context = this.canvas.getContext("2d");
    this.anchor = -1;
    this.drawBoxes = process.attributes.NodeStyle == 'BoxIcon';
    this.selection = new Selection(this);
  };

  Diagram.prototype = new Shape();
  
  Diagram.BOUNDARY_DIM = 25;
  
  Diagram.prototype.draw = function() {

    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    this.prepareDisplay();

    this.label.draw();
    this.steps.forEach(function(step) {
      step.draw();
    });
    this.links.forEach(function(link) {
      link.draw();
    });
    this.subflows.forEach(function(subflow) {
      subflow.draw();
    });
    this.notes.forEach(function(note) {
      note.draw();
    });
    
    if (this.marquee) {
      this.marquee.draw();
    }
  };
  
  // sets display fields and returns a display with w and h for canvas size
  // (for performance reasons, also initializes steps/links arrays and activity impls)
  Diagram.prototype.prepareDisplay = function() {
    var canvasDisplay = { w: 640, h: 480 };
    
    var diagram = this; // forEach inner access
    
    // label
    diagram.label = new Label(this, this.process.name, this.getDisplay(), DC.TITLE_FONT);
    diagram.makeRoom(canvasDisplay, diagram.label.prepareDisplay());
    
    // activities
    diagram.steps = [];
    if (this.process.activities) {
      this.process.activities.forEach(function(activity) {
        var step = new Step(diagram, activity);
        step.implementor = diagram.getImplementor(activity.implementor);
        diagram.makeRoom(canvasDisplay, step.prepareDisplay());
        if (diagram.instance)
          step.applyState(diagram.getActivityInstances(activity.id));
        diagram.steps.push(step);
      });
    }
    
    // transitions
    diagram.links = [];
    diagram.steps.forEach(function(step) {
      if (step.activity.transitions) {
        step.activity.transitions.forEach(function(transition) {
          var link = new Link(diagram, transition, step, diagram.getStep(transition.to));
          diagram.makeRoom(canvasDisplay, link.prepareDisplay());
          if (diagram.instance)
            link.applyState(diagram.getTransitionInstances(link.transition.id));
          diagram.links.push(link);
        });
      }
    });
    
    // embedded subprocesses
    diagram.subflows = [];
    if (this.process.subprocesses) {
      this.process.subprocesses.forEach(function(subproc) {
        var subflow = new Subflow(diagram, subproc);
        diagram.makeRoom(canvasDisplay, subflow.prepareDisplay());
        if (diagram.instance) {
          subflow.mainProcessInstanceId = diagram.instance.processInstanceId; // needed for subprocess & task instance retrieval          
          subflow.applyState(diagram.getSubflowInstances(subflow.subprocess.id));
        }
        diagram.subflows.push(subflow);
      });
    }

    // notes
    diagram.notes = [];
    if (this.process.textNotes) {
      this.process.textNotes.forEach(function(textNote) {
        var note = new Note(diagram, textNote);
        diagram.makeRoom(canvasDisplay, note.prepareDisplay());
        diagram.notes.push(note);
      });
    }
    
    // marquee
    if (this.marquee)
      diagram.makeRoom(canvasDisplay, this.marquee.prepareDisplay());
    
    // allow extra room
    canvasDisplay.w += Diagram.BOUNDARY_DIM;
    canvasDisplay.h += Diagram.BOUNDARY_DIM;
    
    this.canvas.width = canvasDisplay.w;
    this.canvas.height = canvasDisplay.h;
  };
  
  Diagram.prototype.makeRoom = function(canvasDisplay, display) {
    if (display.w > canvasDisplay.w)
      canvasDisplay.w = display.w;
    if (display.h > canvasDisplay.h)
      canvasDisplay.h = display.h;
  };
  
  Diagram.prototype.getStep = function(activityId) {
    for (var i = 0; i < this.steps.length; i++) {
      if (this.steps[i].activity.id == activityId)
        return this.steps[i];
    }
  };

  Diagram.prototype.getLink = function(transitionId) {
    for (var i = 0; i < this.links.length; i++) {
      if (this.links[i].transition.id == transitionId)
        return this.links[i];
    }
  };
  
  Diagram.prototype.getLinks = function(step) {
    var links = [];
    for (var i = 0; i < this.links.length; i++) {
      if (step.activity.id == this.links[i].to.activity.id || step.activity.id == this.links[i].from.activity.id)
        links.push(this.links[i]);
    }
    return links;
  };

  Diagram.prototype.getSubflow = function(subprocessId) {
    for (var i = 0; i < this.subflows.length; i++) {
      if (this.subflows[i].subprocess.id == subprocessId)
        return this.subflows[i];
    }
  };

  Diagram.prototype.getNote = function(textNoteId) {
    for (var i = 0; i < this.notes.length; i++) {
      if (this.notes[i].textNote.id == textNoteId)
        return this.notes[i];
    }
  };
  
  Diagram.prototype.get = function(id) {
    if (id.startsWith('A'))
      return this.getStep(id);
    else if (id.startsWith('T'))
      return this.getLink(id);
    else if (id.startsWith('P'))
      return this.getSubflow(id);
    else if (id.startsWith('N'))
      return this.getNote(id);
  };
  
  Diagram.prototype.addLink = function(from, to) {
    var maxId = 0;
    this.links.forEach(function(link) {
      var linkId = parseInt(link.transition.id.substring(1));
      if (linkId > maxId)
        maxId = linkId;
    });
    var transition = {
        id: 'T' + (maxId + 1),
        event: 'FINISH',
        to: to.activity.id
    };
    from.activity.transitions.push(transition);
    var link = new Link(this, transition, from, to);
    link.display = {type: Link.LINK_TYPES.ELBOW, lx: 0, ly: 0, xs: [0,0], ys: [0,0]};
    link.calc();
    this.links.push();
  };

  Diagram.prototype.getImplementor = function(className) {
    if (this.implementors) {
      for (var i = 0; i < this.implementors.length; i++) {
        var implementor = this.implementors[i];
        if (implementor.implementorClass == className) {
          return implementor;
        }
      }
    }
    // not found -- return placeholder
    return { implementorClass: className };
  };
  
  Diagram.prototype.getActivityInstances = function(id) {
    if (this.instance) {
      var insts = [];  // should always return something, even if empty
      if (this.instance.activities) {
        var procInstId = this.instance.id;
        this.instance.activities.forEach(function(actInst) {
          if ('A' + actInst.activityId == id) {
            actInst.processInstanceId = procInstId; // needed for subprocess & task instance retrieval
            insts.push(actInst);
          }
        });
      }
      insts.sort(function(a1, a2) {
        return a2.id - a1.id;
      });
      return insts;
    }
  };

  Diagram.prototype.getTransitionInstances = function(id) {
    if (this.instance) {
      var insts = [];  // should always return something, even if empty
      if (this.instance.transitions) {
        this.instance.transitions.forEach(function(transInst) {
          if ('T' + transInst.transitionId == id)
            insts.push(transInst);
        });
      }
      insts.sort(function(t1, t2) {
        return t2.id - t1.id;
      });
      return insts;
    }
  };

  Diagram.prototype.getSubflowInstances = function(id) {
    if (this.instance) {
      var insts = [];  // should always return something, even if empty
      if (this.instance.subprocesses) {
        this.instance.subprocesses.forEach(function(subInst) {
          if ('P' + subInst.processId == id)
            insts.push(subInst);
        });
      }
      insts.sort(function(s1, s2) {
        return s2.id - s1.id;
      });
      return insts;
    }
  };
  
  Diagram.prototype.drawState = function(display, instances, ext, adj) {
    if (instances) {
      var count = instances.length > Step.MAX_INSTS ? Step.MAX_INSTS : instances.length;
      for (var i = 0; i < count; i++) {
        var instance = instances[i];
        var rounding = DC.BOX_ROUNDING_RADIUS;
        if (instance.statusCode) {
          var status = Step.STATUSES[instance.statusCode];
          instance.status = status.status;
          var del = Step.INST_W - Step.OLD_INST_W;
          if (ext) {
            var rem = count - i;
            if (i === 0) {
              this.rect(
                  display.x - Step.OLD_INST_W * rem - del, 
                  display.y - Step.OLD_INST_W * rem - del,
                  display.w + Step.OLD_INST_W * 2* rem + 2 * del,
                  display.h + Step.OLD_INST_W * 2 * rem + 2 * del,
                  status.color, status.color, rounding);
            } 
            else {
              this.rect(
                  display.x - Step.OLD_INST_W * rem,
                  display.y - Step.OLD_INST_W * rem,
                  display.w + Step.OLD_INST_W * 2 * rem,
                  display.h + Step.OLD_INST_W * 2 * rem,
                  status.color, status.color, 0);
            }
            rem--;
            this.context.clearRect(
                display.x - Step.OLD_INST_W * rem - 1,
                display.y - Step.OLD_INST_W * rem - 1,
                display.w + Step.OLD_INST_W * 2 * rem + 2,
                display.h + Step.OLD_INST_W * 2 * rem + 2);
          }
          else {
            var x1, y1, w1, h1;
            if (i === 0) {
              this.rect(
                  display.x - adj, 
                  display.y - adj, 
                  display.w + 2 * adj, 
                  display.h + 2* adj, 
                  status.color, status.color, rounding);
              x1 = display.x + del;
              y1 = display.y + del;
              w1 = display.w - 2 * del;
              h1 = display.h - 2 * del;
            } 
            else {
              x1 = display.x + Step.OLD_INST_W * i + del;
              y1 = display.y + Step.OLD_INST_W * i + del;
              w1 = display.w - Step.OLD_INST_W * 2 * i - 2 * del;
              h1 = display.h - Step.OLD_INST_W * 2 * i - 2 * del;
              if (w1 > 0 && h1 > 0)
                this.rect(x1, y1, w1, h1, status.color, status.color);
            }
            x1 += Step.OLD_INST_W - 1;
            y1 += Step.OLD_INST_W - 1;
            w1 -= 2 * Step.OLD_INST_W - 2;
            h1 -= 2 * Step.OLD_INST_W - 2;
            if (w1 > 0 && h1 > 0)
              this.context.clearRect(x1, y1, w1, h1);
          }
        }
      }
    }
  };
  
  Diagram.prototype.roundedRect = function(x, y, w, h, border, fill) {
    this.rect(x, y, w, h, border, fill, DC.BOX_ROUNDING_RADIUS);
  };
  
  Diagram.prototype.rect = function(x, y, w, h, border, fill, r) {
    if (border)
      this.context.strokeStyle = border;
    if (fill)
      this.context.fillStyle = fill;

    if (!r) {
      this.context.strokeRect(x, y, w, h);
      if (fill)
        this.context.fillRect(x, y, w, h);
    }
    else {
      // rounded corners
      this.context.beginPath();
      this.context.moveTo(x + r, y);
      this.context.lineTo(x + w - r, y);
      this.context.quadraticCurveTo(x + w, y, x + w, y + r);
      this.context.lineTo(x + w, y + h - r);
      this.context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.context.lineTo(x + r, y + h);
      this.context.quadraticCurveTo(x, y + h, x, y + h - r);
      this.context.lineTo(x, y + r);
      this.context.quadraticCurveTo(x, y, x + r, y);
      this.context.closePath();
      
      this.context.stroke();
      if (fill)
        this.context.fill();
    }
    
    this.context.fillStyle = DC.DEFAULT_COLOR;
    this.context.strokeStyle = DC.DEFAULT_COLOR;
  };
  
  Diagram.prototype.drawOval = function(x, y, w, h, fill, fadeTo) {
    var kappa = 0.5522848;
    var ox = (w / 2) * kappa; // control point offset horizontal
    var oy = (h / 2) * kappa; // control point offset vertical
    var xe = x + w; // x-end
    var ye = y + h; // y-end
    var xm = x + w / 2; // x-middle
    var ym = y + h / 2; // y-middle

    this.context.beginPath();
    this.context.moveTo(x, ym);
    this.context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    this.context.closePath(); // not used correctly? (use to close off open path)
    if (typeof fill === 'undefined') {
      this.context.stroke();
    }
    else {
      if (typeof fadeTo === 'undefined') {
        this.context.fillStyle = fill;
      }
      else {
        var gradient = this.context.createLinearGradient(x, y, x + w, y + h);
        gradient.addColorStop(0, fill);
        gradient.addColorStop(1, 'white');
        this.context.fillStyle = gradient;
      }
      this.context.fill();
      this.context.stroke();
    }
    this.context.fillStyle = DC.DEFAULT_COLOR;
  };
  
  Diagram.prototype.drawLine = function(x1, y1, x2, y2, color) {
    if (color)
      this.context.strokeStyle = color;
    this.context.beginPath();
    this.context.moveTo(x1, y1);
    this.context.lineTo(x2, y2);
    this.context.stroke();
    this.context.strokeStyle = DC.DEFAULT_COLOR;
  };
  
  Diagram.prototype.drawDiamond = function(x, y, w, h) {
    var xh = x + w / 2;
    var yh = y + h / 2;
    this.context.beginPath();
    this.context.moveTo(x, yh);
    this.context.lineTo(xh, y);
    this.context.lineTo(x + w, yh);
    this.context.lineTo(xh, y + h);
    this.context.lineTo(x, yh);
    this.context.closePath();
    this.context.stroke();
  };
  
  Diagram.prototype.drawImage = function(src, x, y) {
    src = this.imgBase + '/' + src;
    if (!this.images)
      this.images = {};
    var img = this.images[src];
    if (!img) {
      img = new Image();
      img.src = src;
      var context = this.context;
      var images = this.images;
      img.onload = function() {
        context.drawImage(img, x, y);
        images[src] = img;
      };
    }
    else {
      this.context.drawImage(img, x, y);
    }
  };
  
  Diagram.prototype.onMouseDown = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    var x = e.clientX - rect.left;
    var y = e.clientY - rect.top;
    // starting points for drag
    this.dragX = x;
    this.dragY = y;
    
    var selObj = this.getHoverObj(x, y);
    
    if (this.editable && e.ctrlKey) {
      if (selObj) {
        if (this.selection.includes(selObj))
          this.selection.remove(selObj);
        else
          this.selection.add(selObj);
        selObj.select();
      }
    }
    else {
      if (!this.selection.includes(selObj)) {
        // normal single select
        this.selection.setSelectObj(selObj);
        this.unselect();
        if (this.selection.getSelectObj()) {
          this.selection.getSelectObj().select();
          if (this.editable && e.shiftKey && this.selection.getSelectObj().isStep)
            this.shiftDrag = true;
        }
      }
    }
  };
  
  Diagram.prototype.onMouseUp = function(e) {
    if (this.shiftDrag && this.dragX && this.dragY) {
      if (this.selection.getSelectObj() && this.selection.getSelectObj().isStep) {
        var rect = this.canvas.getBoundingClientRect();
        var x = e.clientX - rect.left;
        var y = e.clientY - rect.top;
        var destObj = this.getHoverObj(x, y);
        if (destObj && destObj.isStep) {
          this.addLink(this.selection.getSelectObj(), destObj);
          this.draw();
        }
      }
    }
    this.shiftDrag = false;
    
    if (this.marquee) {
      this.selection.setSelectObj(null);
      var selObjs = this.marquee.getSelectObjs();
      for (let i = 0; i < selObjs.length; i++) {
        selObjs[i].select();
        this.selection.add(selObjs[i]);
      }
      this.marquee = null;
    }
    else {
      this.selection.reselect();
    }
  };
  
  Diagram.prototype.onMouseOut = function(e) {
    // TODO anything?
  };
  
  Diagram.prototype.onMouseMove = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    var x = e.clientX - rect.left;
    var y = e.clientY - rect.top;
    this.anchor = -1;
    this.hoverObj = this.getHoverObj(x, y);
    if (this.hoverObj) {
      if (this.editable && (this.hoverObj == this.selection.getSelectObj())) {
        this.anchor = this.hoverObj.getAnchor(x, y);
        if (this.anchor >= 0) {
          if (this.hoverObj.isLink) {
            $document[0].body.style.cursor = 'crosshair';
          }
          else {
            if (this.anchor === 0 || this.anchor == 2)
              $document[0].body.style.cursor = 'nw-resize';
            else if (this.anchor == 1 || this.anchor == 3)
              $document[0].body.style.cursor = 'ne-resize';
          }
        }
        else {
          $document[0].body.style.cursor = 'pointer';
        }
      }
      else {
        $document[0].body.style.cursor = 'pointer';
      }
    }
    else {
      $document[0].body.style.cursor = '';
    }
    
  };
  
  Diagram.prototype.onMouseDrag = function(e) {
    if (this.editable && this.dragX && this.dragY && !e.ctrlKey) {
      var rect = this.canvas.getBoundingClientRect();
      var x = e.clientX - rect.left;
      var y = e.clientY - rect.top;
      var deltaX = x - this.dragX;
      var deltaY = y - this.dragY;

      if (Math.abs(deltaX) > DC.MIN_DRAG || Math.abs(deltaY) > DC.MIN_DRAG) {
        
        if (x > rect.right - Diagram.BOUNDARY_DIM)
          this.canvas.width = this.canvas.width + Diagram.BOUNDARY_DIM;
        if (y > rect.bottom - Diagram.BOUNDARY_DIM)
          this.canvas.height = this.canvas.height + Diagram.BOUNDARY_DIM;

        if (this.selection.getSelectObj()) {
          var diagram = this;
          if (this.shiftDrag) {
            if (this.selection.getSelectObj().isStep) {
              this.draw();
              this.drawLine(this.dragX, this.dragY, x, y, DC.LINE_COLOR);
            }
          }
          else if (this.anchor >= 0) {
            if (this.selection.getSelectObj().isLink) {
              this.selection.getSelectObj().moveAnchor(this.anchor, x - this.dragX, y - this.dragY);
              this.draw();
            }
            if (this.selection.getSelectObj().resize) {
              if (this.selection.getSelectObj().isStep) {
                let activityId = this.selection.getSelectObj().activity.id;
                let step = this.getStep(activityId);
                if (step) {
                  this.selection.getSelectObj().resize(this.dragX, this.dragY, x - this.dragX, y - this.dragY);
                  this.getLinks(step).forEach(function(link) {
                    link.recalc(step);
                  });
                }
                else {
                  // try subflows
                  this.subflows.forEach(function(subflow) {
                    let step = subflow.getStep(activityId);
                    if (step) {
                      // only within bounds of subflow
                      diagram.selection.getSelectObj().resize(diagram.dragX, diagram.dragY, x - diagram.dragX, y - diagram.dragY, subflow.display);
                      subflow.getLinks(step).forEach(function(link) {
                        link.recalc(step);
                      });
                    }
                  });
                }
              }
              else {
                this.selection.getSelectObj().resize(this.dragX, this.dragY, x - this.dragX, y - this.dragY);
              }
              this.draw();
              var obj = this.getHoverObj(x, y);
              if (obj)
                obj.select();
              return true;
            }
          }
          else {
            this.selection.move(this.dragX, this.dragY, deltaX, deltaY);
            // non-workflow selection may not be reselected after move
            var hovObj = this.diagram.getHoverObj(x, y);
            if (hovObj)
              hovObj.select();
            return true;
          }
        }
        else {
          if (this.marquee) {
            this.marquee.resize(this.dragX, this.dragY, x - this.dragX, y - this.dragY);
          }
          else {
            this.marquee = new Marquee(this);
            this.marquee.start(this.dragX, this.dragY);
          }
          this.draw();
        }
      }
    }
  };
  
  Diagram.prototype.getHoverObj = function(x, y) {
    if (this.label.isHover(x, y))
      return this.label;
    // links checked before steps for better anchor selectability
    for (i = 0; i < this.subflows.length; i++) {
      var subflow = this.subflows[i];
      if (subflow.title.isHover(x, y))
        return subflow;
      if (subflow.isHover(x, y)) {
        for (j = 0; j < subflow.links.length; j++) {
          if (subflow.links[j].isHover(x, y))
            return subflow.links[j];
        }
        for (var j = 0; j < subflow.steps.length; j++) {
          if (subflow.steps[j].isHover(x, y))
            return subflow.steps[j];
        }
      }
    }
    for (i = 0; i < this.links.length; i++) {
      if (this.links[i].isHover(x, y))
        return this.links[i];
    }
    for (var i = 0; i < this.steps.length; i++) {
      if (this.steps[i].isHover(x, y))
        return this.steps[i];
    }
    for (i = 0; i < this.notes.length; i++) {
      if (this.notes[i].isHover(x, y))
        return this.notes[i];
    }
  };

  // when nothing selectable is hovered
  Diagram.prototype.getBackgroundObj = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    var x = e.clientX - rect.left;
    var y = e.clientY - rect.top;
    var bgObj = this;
    for (var i = 0; i < this.subflows.length; i++) {
      if (this.subflows[i].isHover(x, y)) {
        bgObj = this.subflows[i];
        break;
      }
    }
    
    if (bgObj == this)
      this.label.select();
    else
      bgObj.select();
    
    return bgObj;
  };
  
  // removes anchors from currently selected obj, if any
  Diagram.prototype.unselect = function() {
    this.draw();
  };
  
  Diagram.prototype.getAnchor = function(x, y) {
    return -1; // not applicable
  };
  
  return Diagram;
  
}]);

// selected object(s)
workflowMod.factory('Selection', ['mdw', function(mdw) {
  
  var Selection = function(diagram) {
    this.diagram = diagram;
    this.selectObjs = [];
  };

  Selection.prototype.includes = function(obj) {
    for (var i = 0; i < this.selectObjs.length; i++) {
      if (this.selectObjs[i] === obj)
        return true;
    }
    return false;
  };
  
  Selection.prototype.isMulti = function() {
    return this.selectObjs.length > 1;
  };

  Selection.prototype.getSelectObj = function() {
    if (this.selectObjs.length === 0)
      return null;
    else
      return this.selectObjs[0];
  };
  
  Selection.prototype.setSelectObj = function(obj) {
    this.selectObjs = obj ? [obj] : [];
  };
  
  Selection.prototype.add = function(obj) {
    if (!this.includes(obj)) {
      this.selectObjs.push(obj);
      if (obj.isStep) {
        // add any contained links
        var stepLinks;
        let step = this.diagram.getStep(obj.activity.id);
        if (step) {
          stepLinks = this.diagram.getLinks(obj);
        }
        else {
          for (let i = 0; i < this.diagram.subflows.length; i++) {
            let subflow = this.diagram.subflows[i];
            let step = subflow.getStep(obj.activity.id);
            stepLinks = subflow.getLinks(obj);
            if (stepLinks)
              break;
          }
        }

        if (stepLinks) {
          for (let i = 0; i < stepLinks.length ; i++) {
            var stepLink = stepLinks[i];
            if (stepLink.from === obj) {
              if (this.includes(stepLink.to)) {
                this.add(stepLink);
                stepLink.select();
              }
            }
            else {
              if (this.includes(stepLink.from)) {
                this.add(stepLink);
                stepLink.select();
              }
            }
          }
        }
      }
    }
  };

  Selection.prototype.remove = function(obj) {
    var newSel = [];
    for (var i = 0; i < this.selectObjs.length; i++) {
      if (this.selectObjs[i] !== obj)
        newSel.push(this.selectObjs[i]);
    }
    this.selectObjs = newSel;
  };
  
  // works for the primary (single) selection to reenable anchors
  Selection.prototype.reselect = function() {
    if (this.getSelectObj() && !this.isMulti()) {
      var selObj = this.getSelectObj();
      var id = selObj.workflowItem ? selObj.workflowItem.id : null;
      if (id) {
        this.setSelectObj(this.diagram.get(id));
        if (!this.getSelectObj()) {
          for (var i = 0; i < this.diagram.subflows.length; i++) {
            this.setSelectObj(this.diagram.subflows[i].get(id));
            if (this.getSelectObj())
              break;
          }
        }
      }
      else {
        this.setSelectObj(this.diagram.label);
      }
    }
  };
  
  Selection.prototype.move = function(startX, startY, deltaX, deltaY) {
    var selection = this;
    
    if (!this.isMulti() && this.getSelectObj().isLink) {
      // move link label
      var link = this.getSelectObj();
      if (link.label && link.label.isHover(startX, startY)) {
        link.moveLabel(deltaX, deltaY);
      }
    }
    else {
      for (let i = 0; i < this.selectObjs.length; i++) {
        let selObj = this.selectObjs[i];
        if (selObj.isStep) {
          let step = this.diagram.getStep(selObj.activity.id);
          if (step) {
            selObj.move(deltaX, deltaY);
            let links = this.diagram.getLinks(step);
            for (let j = 0; j < links.length; j++) {
              if (!this.includes(links[j]))
                links[j].recalc(step);
            }
          }
          else {
            // try subflows
            for (let j = 0; j < this.diagram.subflows.length; j++) {
              let subflow = this.diagram.subflows[j];
              let step = subflow.getStep(selObj.activity.id);
              if (step) {
                // only within bounds of subflow
                selObj.move(deltaX, deltaY, subflow.display);
                let links = subflow.getLinks(step);
                for (let k = 0; k < links.length; k++) {
                  if (!this.includes(links[k]))
                    links[k].recalc(step);
                }
              }
            }
          }
        }
        else {
          // TODO: prevent subproc links in multisel from moving beyond border
          selObj.move(deltaX, deltaY);
        }
      }
    }
    
    this.diagram.draw();
    
    for (let i = 0; i < this.selectObjs.length; i++) {
      let selObj = this.selectObjs[i];
      let reselObj = this.find(selObj);
      if (reselObj) {
        reselObj.select();
      }
    }
    // TODO: diagram label loses select
  };
  
  // re-find the selected object after it's been moved
  Selection.prototype.find = function(obj) {
    if (obj.workflowItem && obj.workflowItem.id) {
      var found = this.diagram.get(obj.workflowItem.id);
      if (found)
        return found;
      
      // try subflows
      for (let i = 0; i < this.diagram.subflows.length; i++) {
        let subflow = this.diagram.subflows[i];
        found = subflow.get(obj.workflowItem.id);
        if (found)
          return found;
      }
    }    
  };
  
  return Selection;
}]);

// cache implementors
workflowMod.factory('mdwImplementors', ['mdw', function(mdw) {
  return {
    set: function(implementors) {
      this.implementors = implementors;
    },
    get: function() {
      return this.implementors;
    }
  };
}]);

// attributes
//   - process (object): packageName and name must be populated
//     optional process fields
//       - version: for non-latest process version
//       - renderState: if true, display runtime overlay
//       - editable: if true, workflow can be modified
//   - service-base: endpoint url root
//   - hub-base: MDWHub url root
workflowMod.directive('mdwWorkflow', [function() {
  return {
    restrict: 'E',
    templateUrl: 'ui/workflow.html',
    scope: {
      process: '=process',
      onChange: '=onchange',
      renderState: '@renderState',
      editable: '@editable',
      serviceBase: '@serviceBase',
      hubBase: '@hubBase'
    },
    controller: 'MdwWorkflowController',
    controllerAs: 'mdwWorkflow',
    link: function link(scope, elem, attrs, ctrls) {
      scope.init(angular.element(elem[0].getElementsByClassName('mdw-canvas')[0]));
      scope.$on('$destroy', function() {
        scope.dest();
      });
    }
  };
}]);
// source: web/js/mdw.js
var mdwMod = angular.module('mdw', []);

mdwMod.factory('mdw', function() {
  return {
    // $mdwVersion and $mdwHubRoot are set in logical root.js -- See RootServlet.java
    version: $mdwVersion,
    build: $mdwBuild,
    autoTestWebSocketUrl: $mdwAutoTestWebSocketUrl,
    roots: {
      services: $mdwServicesRoot,
      hub: $mdwHubRoot,
      webTools: $mdwWebToolsRoot
    },
    serviceParams: function() {
      return { 
        app: 'mdw-admin'
      };
    },
    hubParams: function() {
      return { 
        root: this.roots.hub,
        app: 'mdw-admin'
      };
    },    
    hubLoading: function(loading) {
      // TODO: figure out a more angular way
      var isIe = (navigator.userAgent.indexOf('MSIE') >= 0 || navigator.userAgent.indexOf('Trident') >= 0);
      setTimeout(function() {
        var logo, load;
        if (loading) {
          if (isIe) {
            logo = document.getElementById('hub_logo');
            if (logo)
              logo.src = logo.src.substring(0, logo.src.lastIndexOf('/')) + '/hub_loading.gif';
          }
          else {
            logo = document.getElementById('hub_logo');
            if (logo)
              logo.style.display = 'none';
            load = document.getElementById('hub_loading');
            if (load)
              load.style.display = 'inline';
          }
        }
        else {
          if (isIe) {
            logo = document.getElementById('hub_logo');
            if (logo)
              logo.src = logo.src.substring(0, logo.src.lastIndexOf('/')) + '/hub_logo.png';
          }
          else {
            load = document.getElementById('hub_loading');
            if (load)
              load.style.display = 'none';
            logo = document.getElementById('hub_logo');
            if (logo)
              logo.style.display = 'inline';
          }
        }
      }, 0);
    }
  };
});
// source: web/js/util.js
var utilMod = angular.module('util', []);
utilMod.factory('util', ['$http', 'mdw', function($http, mdw) {
  return {
    months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayMs: 24 * 3600 * 1000, 
    monthAndDay: function(date) {
      return this.months[date.getMonth()] + ' ' + date.getDate();
    },
    serviceDate: function(date) {
      return date.getFullYear() + '-' + this.months[date.getMonth()] + '-' + this.padLeading(date.getDate(), 2, '0');
    },
    formatDateTime: function(date) {
      var ampm = 'am';
      var hours = date.getHours();
      if (hours > 11)
        ampm = 'pm';
      if (hours > 12)
        hours = hours - 12;
      return this.serviceDate(date) + ' ' + hours + ':' + this.padLeading(date.getMinutes(), 2, '0') + ':' + this.padLeading(date.getSeconds(), 2, '0') + ' ' + ampm;
    },
    correctDbDate: function(date, dbDate) {
      var adj = Date.now() - dbDate.getTime();
      return new Date(date.getTime() + adj);
    },
    past: function(date) {
      var ret = this.months[date.getMonth()] + ' ' + date.getDate();
      var agoMs = Date.now() - date.getTime();
      if (agoMs < 60000) {
        var secs = Math.round(agoMs/1000);
        ret =  secs + (secs == 1 ? ' second ago' : ' seconds ago');
      }
      else if (agoMs < 3600000) {
        var mins = Math.round(agoMs/60000);
        ret = mins + (mins == 1 ? ' minute ago' : ' minutes ago');
      }
      else if (agoMs < 86400000) {
        var hrs = Math.round(agoMs/3600000);
        ret = hrs + (hrs == 1 ? ' hour ago' : ' hours ago');
      }
      else if (agoMs < 2592000000) {
        var days = Math.round(agoMs/86400000);
        ret = days + (days == 1 ? ' day ago' : ' days ago');
      }
      return ret;
    },
    future: function(date) {
      var ret = this.months[date.getMonth()] + ' ' + date.getDate();
      var inMs = date.getTime() - Date.now();
      if (inMs < 60000) {
        var secs = Math.round(inMs/1000);
        ret =  'in ' + secs + (secs == 1 ? ' second' : ' seconds');
      }
      else if (inMs < 3600000) {
        var mins = Math.round(inMs/60000);
        ret = 'in ' + mins + (mins == 1 ? ' minute' : ' minutes');
      }
      else if (inMs < 86400000) {
        var hrs = Math.round(inMs/3600000);
        ret = 'in ' + hrs + (hrs == 1 ? ' hour' : ' hours');
      }
      else if (inMs < 2592000000) {
        var days = Math.round(inMs/86400000);
        ret = 'in ' + days + (days == 1 ? ' day' : ' days');
      }
      return ret;
    },
    padLeading: function(str, len, ch) {
      var ret = '' + str; // convert if nec.
      if (!ch)
        ch = ' ';
      while (ret.length < len)
        ret = ch + ret;
      return ret;
    },
    padTrailing: function(str, len, ch) {
      var ret = '' + str; // convert if nec.
      if (!ch)
        ch = ' ';
      while (ret.length < len)
        ret = ret + ch;
      return ret;
    },
    isMobile: function() {
      var check = false;
      // regex from detectmobilebrowsers.com
      (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera); // jshint ignore:line
      return check;
    },
    urlParams: function() {
      // params need to be on url before hash (eg: http://localhost:8080/mdw-admin/?mdwMobile=true#/tasks)
      var params = {};
      var search = /([^&=]+)=?([^&]*)/g;
      var match;
      while ((match = search.exec(window.location.search.substring(1))) !== null)
       params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
      return params;
    },
    getProperties: function(obj) {
      var props = [];
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          props.push(prop);
        }
      }
      return props;
    },
    isEmpty: function(obj) {
      return !obj || (Object.keys(obj).length === 0 && obj.constructor === Object);
    },
    getMdwProperties: function() {
      return this.mdwProperties;
    },
    loadMdwProperties: function() {
      var thisUtil = this;
      var promise = $http.get(mdw.roots.services + '/services/Values/SYSTEM/mdwProperties?app=mdw-admin').then(function (response) {
        thisUtil.mdwProperties = response.data;
      });
      return promise;      
    },
    getLanguage: function(assetName) {
      var lastDot = assetName.lastIndexOf('.');
      if (lastDot > 0 && lastDot < assetName.length - 2) {
        var ext = assetName.substring(lastDot + 1);
        if (ext == 'md')
          return 'markdown';
        else if (ext == 'test')
          return 'groovy';
        else if (ext == 'spring' || ext == 'camel')
          return 'xml';
        else if (ext === 'proc' || ext === 'task' || ext === 'impl' || ext === 'evth' || ext == 'pagelet')
            return 'json';
        return ext;
      }
      return null;
    },
    nextMinor: function(version) {
      var dot = version.indexOf('.');
      var maj = version.substring(0, dot);
      var min = version.substring(dot + 1);
      return maj + '.' + (parseInt(min) + 1);
    },
    nextMajor: function(version) {
      var dot = version.indexOf('.');
      var maj = version.substring(0, dot);
      return (parseInt(maj) + 1) + '.0';
    },
    buildException: function(exceptHolder) {
    	// Uses the callback mechanism to update the except variable (gets around jshint error)
    	return function(el) {
            exceptHolder.exceptionMessage += '\tat ' + el.class;
            if (el.file) {
              exceptHolder.exceptionMessage += '(' + el.file;
              if (el.line) {
                exceptHolder.exceptionMessage += ':' + el.line;
              }
              exceptHolder.exceptionMessage += ')\n';
            }

    	};
    },
    asException: function(value) {
      var except = '';
      if (value.value) {
        var activityException = JSON.parse(value.value);
        if (activityException.activityException)
          activityException = activityException.activityException;
        if (activityException) {
          var ex = activityException;
          while (ex) {
            if (ex.throwable)
              except += ex.throwable + ':';
            if (ex.code)
              except += '(code=' + ex.code + '):';
            if (ex.message)
              except += ' ' + ex.message;
            except += '\n';
            if (ex.stackElements) {
              var exceptHolder = {};
              exceptHolder.exceptionMessage = '';
              ex.stackElements.forEach(this.buildException(exceptHolder));
              except += exceptHolder.exceptionMessage;
            }
            if (ex.cause)
              except += 'Caused By: ';
            ex = ex.cause;
          }
        }
      }
      return except;
    }
  };
}]);
// source: web/js/constants.js
var constantsMod = angular.module('constants', []);

constantsMod.constant('PROCESS_STATUSES', ['Pending', 'In Progress', 'Failed', 'Completed', 'Canceled', 'Waiting']);
constantsMod.constant('TASK_STATUSES', ['Open', 'Assigned', 'In Progress', 'Completed', 'Canceled']);
constantsMod.constant('ACTIVITY_STATUSES', ['In Progress', 'Failed', 'Waiting']);
constantsMod.constant('STUCK_ACTIVITY_STATUSES', ['In Progress', 'Failed', 'Canceled', 'Waiting']);
constantsMod.constant('REQUEST_STATUSES', ['In Progress', 'Failed', 'Waiting', 'Completed']);
// these are simplified
constantsMod.constant('TASK_ADVISORIES', ['Jeopardy', 'Alert', 'Invalid']);
constantsMod.constant('HTTP_METHODS', ['POST', 'PUT', 'GET', 'DELETE', 'PATCH']);

constantsMod.constant('QUEUE_NAMES', [
  'com.centurylink.mdw.external.event.queue',
  'com.centurylink.mdw.intra.event.queue',
  'com.centurylink.mdw.process.handler.queue',
  'com.centurylink.mdw.config.topic'
]);

constantsMod.constant('EXCEL_DOWNLOAD', 'DownloadFormat=xlsx');
constantsMod.constant('JSON_DOWNLOAD', 'DownloadFormat=json');
constantsMod.constant('ZIP_DOWNLOAD', 'DownloadFormat=zip');

// TODO: should be dynamic through a service
constantsMod.constant('DOCUMENT_TYPES', {
  'org.w3c.dom.Document': 'xml',
  'org.apache.xmlbeans.XmlObject': 'xml',
  'java.lang.Object': 'java',
  'org.json.JSONObject': 'json',
  'groovy.util.Node': 'xml',
  'com.centurylink.mdw.xml.XmlBeanWrapper': 'xml',
  'com.centurylink.mdw.model.StringDocument': 'text',
  'com.centurylink.mdw.model.HTMLDocument': 'html',
  'javax.xml.bind.JAXBElement': 'xml',
  'org.apache.camel.component.cxf.CxfPayload': 'xml',
  'com.centurylink.mdw.common.service.Jsonable': 'json',
  'org.yaml.snakeyaml.Yaml': 'yaml',
  'java.lang.Exception': 'json'
});

constantsMod.constant('WORKFLOW_STATUSES', [
   {status: 'Pending', color: 'blue'},
   {status: 'In Progress', color: 'green'},
   {status: 'Failed', color: 'red'},
   {status: 'Completed', color: 'black'},
   {status: 'Canceled', color: 'darkgray'},
   {status: 'Hold', color: 'cyan'},
   {status: 'Waiting', color: 'yellow'}
 ]);
// source: dist/hub-ui/templates.js
angular.module('mdw').run(['$templateCache', function($templateCache) {
  'use strict';

  $templateCache.put('ui/action-pop-button.html',
    "<ng-transclude popover-placement=\"{{popPlace}}\">\r" +
    "\n" +
    "</ng-transclude>"
  );


  $templateCache.put('ui/chart.html',
    "<div class=\"panel-heading mdw-heading\">\r" +
    "\n" +
    "  <div class=\"mdw-heading-label\">{{label}} for the:</div>\r" +
    "\n" +
    "  <div class=\"mdw-heading-input\">\r" +
    "\n" +
    "    <div class=\"mdw-inner-addon mdw-right-addon\" uib-dropdown>\r" +
    "\n" +
    "      <i class=\"glyphicon glyphicon-chevron-down\"></i>\r" +
    "\n" +
    "      <input type=\"text\" class=\"form-control mdw-inline mdw-dropfilter mdw-med-width\"  \r" +
    "\n" +
    "        value=\"{{span}}\" uib-dropdown-toggle readonly>\r" +
    "\n" +
    "      <ul class=\"dropdown-menu mdw-dropdown-menu\" uib-dropdown-menu aria-labelledby=\"simple-dropdown\">\r" +
    "\n" +
    "        <li ng-repeat=\"sp in spans\">\r" +
    "\n" +
    "          <a href=\"\" ng-click=\"setSpan(sp)\">{{sp}}</a>\r" +
    "\n" +
    "        </li>\r" +
    "\n" +
    "      </ul>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  <span class=\"mdw-heading-label mdw-med-indent\">by:</span>\r" +
    "\n" +
    "  <div class=\"mdw-heading-input\">\r" +
    "\n" +
    "    <div class=\"mdw-inner-addon mdw-right-addon\" uib-dropdown>\r" +
    "\n" +
    "      <i class=\"glyphicon glyphicon-chevron-down\"></i>\r" +
    "\n" +
    "      <input type=\"text\" class=\"form-control mdw-inline mdw-dropfilter mdw-med-width\"  \r" +
    "\n" +
    "        value=\"{{breakdown}}\" uib-dropdown-toggle readonly>\r" +
    "\n" +
    "      <ul class=\"dropdown-menu mdw-dropdown-menu\" uib-dropdown-menu aria-labelledby=\"simple-dropdown\">\r" +
    "\n" +
    "        <li ng-repeat=\"bd in breakdowns\">\r" +
    "\n" +
    "          <a href=\"\" ng-click=\"setBreakdown(bd)\">{{bd}}</a>\r" +
    "\n" +
    "        </li>\r" +
    "\n" +
    "      </ul>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  \r" +
    "\n" +
    "  <!-- TODO: wrap attribute varies according to buttons included -->\r" +
    "\n" +
    "  <mdw-actions wrap=\"1170px\">\r" +
    "\n" +
    "    <!-- TODO: Actions is only when something selected (also, gravity not used) -->\r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" mdw-action-pop-button \r" +
    "\n" +
    "      ng-if=\"getBreakdown()\" uib-popover-template=\"'ui/chartSelect.html'\" select-pop> \r" +
    "\n" +
    "      <span class=\"glyphicon glyphicon-ok\"></span> Select\r" +
    "\n" +
    "    </button>\r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" mdw-action-pop-button \r" +
    "\n" +
    "      uib-popover-template=\"'ui/chartFilters.html'\"> \r" +
    "\n" +
    "      <span class=\"glyphicon glyphicon-filter\"></span> Filter\r" +
    "\n" +
    "    </button>        \r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" ng-click=\"downloadExcel()\">\r" +
    "\n" +
    "      <span class=\"glyphicon glyphicon-download-alt\"></span> Export\r" +
    "\n" +
    "    </button>        \r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" ng-click=\"goList()\">\r" +
    "\n" +
    "      <span class=\"glyphicon glyphicon-menu-hamburger\"></span> List\r" +
    "\n" +
    "    </button>        \r" +
    "\n" +
    "  </mdw-actions>\r" +
    "\n" +
    "  \r" +
    "\n" +
    "</div>\r" +
    "\n" +
    "<div class=\"mdw-section\">\r" +
    "\n" +
    "  <canvas id=\"line\" class=\"chart chart-line\" chart-options=\"chartOptions\" chart-data=\"data\"\r" +
    "\n" +
    "    chart-labels=\"labels\" chart-legend=\"true\" chart-series=\"series\"\r" +
    "\n" +
    "    chart-click=\"onClick\" chart-hover=\"onHover\">\r" +
    "\n" +
    "  </canvas>\r" +
    "\n" +
    "  <div ng-bind-html=\"chartLegend | markdown | unsafe\">\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "</div>"
  );


  $templateCache.put('ui/chartFilters.html',
    "<div>\r" +
    "\n" +
    "  <div>\r" +
    "\n" +
    "    <label class=\"mdw-label\">Ending:</label>\r" +
    "\n" +
    "    <div class=\"mdw-flex-item\">\r" +
    "\n" +
    "      <input class=\"form-control mdw-med-width\" type=\"text\" ng-model=\"filter.ending\" \r" +
    "\n" +
    "        ng-change=\"updateRange()\" uib-datepicker-popup=\"yyyy-MMM-dd\" is-open=\"filterCalIsOpen\" \r" +
    "\n" +
    "        datepicker-options=\"dateOptions\" ng-required=\"true\" close-text=\"OK\" />\r" +
    "\n" +
    "      <button type=\"button\" class=\"btn btn-default\" \r" +
    "\n" +
    "        ng-click=\"filterCalIsOpen ? filterCalIsOpen = false : filterCalIsOpen = true\">\r" +
    "\n" +
    "        <i class=\"glyphicon glyphicon-calendar\"></i>\r" +
    "\n" +
    "      </button>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  <div class=\"mdw-med-width mdw-vsm-indent\" ng-if=\"statuses && breakdown != 'Status'\">\r" +
    "\n" +
    "    <label class=\"mdw-label\">Status:</label>\r" +
    "\n" +
    "    <div class=\"mdw-inner-addon mdw-right-addon\" uib-dropdown dropdown-append-to-body=\"true\">\r" +
    "\n" +
    "      <i class=\"glyphicon glyphicon-chevron-down\"></i>\r" +
    "\n" +
    "      <input type=\"text\" class=\"form-control mdw-inline mdw-dropfilter\" \r" +
    "\n" +
    "        value=\"{{filter.status}}\" uib-dropdown-toggle readonly>\r" +
    "\n" +
    "      <ul class=\"dropdown-menu mdw-dropdown-menu\" uib-dropdown-menu aria-labelledby=\"simple-dropdown\">\r" +
    "\n" +
    "        <li ng-repeat=\"status in statuses\">\r" +
    "\n" +
    "          <a href=\"\" ng-click=\"setStatus(status)\">{{status}}</a>\r" +
    "\n" +
    "        </li>\r" +
    "\n" +
    "      </ul>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  <div class=\"mdw-vmed-indent\">\r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" ng-click=\"resetFilter();closePopover();updateRange();\">Reset</button>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "</div>"
  );


  $templateCache.put('ui/chartSelect.html',
    "<div>\r" +
    "\n" +
    "  <div>\r" +
    "\n" +
    "    <label class=\"mdw-label\">{{selectLabel}}:</label>\r" +
    "\n" +
    "    <ul class=\"dropdown-menu mdw-popover-menu mdw-check-menu mdw-bordered-menu\">\r" +
    "\n" +
    "      <li ng-repeat=\"top in tops\">\r" +
    "\n" +
    "        <div class=\"mdw-checked\" ng-if=\"isSelected(top[selField])\">\r" +
    "\n" +
    "          <i class=\"glyphicon glyphicon-ok\"></i>\r" +
    "\n" +
    "          <a class=\"mdw-drop-selected\" href=\"\" title=\"{{getTitle(top)}}\" ng-click=\"deselect(top[selField])\">\r" +
    "\n" +
    "            {{getLabel(top)}}\r" +
    "\n" +
    "          </a>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "        <a ng-if=\"!isSelected(top[selField])\" href=\"\" title=\"{{getTitle(top)}}\" ng-click=\"select(top[selField])\">\r" +
    "\n" +
    "          {{getLabel(top)}}\r" +
    "\n" +
    "        </a>\r" +
    "\n" +
    "      </li>\r" +
    "\n" +
    "    </ul>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  <div class=\"mdw-vsm-indent\">\r" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-primary mdw-btn\" ng-click=\"applySelect()\">Apply</button>\r" +
    "\n" +
    "    <button type=\"button\" class=\"btn mdw-btn mdw-cancel-btn mdw-float-right\" ng-click=\"cancelSelect()\">Cancel</button>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "</div>"
  );


  $templateCache.put('ui/list.html',
    "<div>\r" +
    "\n" +
    "</div>\r" +
    "\n" +
    "<ul class=\"{{styleClass}}\" infinite-scroll=\"getNextPage()\" infinite-scroll-distance=\"scrollBuffer\"\r" +
    "\n" +
    "  infinite-scroll-disabled=\"!hasMore()\">\r" +
    "\n" +
    "  <li ng-repeat=\"item in items\">\r" +
    "\n" +
    "    <div ng-include=\"itemTemplate\"></div>\r" +
    "\n" +
    "  </li>\r" +
    "\n" +
    "</ul>"
  );


  $templateCache.put('ui/mdw-actions.html',
    "<!-- transcluded content for mdw-actions buttons -->\r" +
    "\n" +
    "<style scoped>\r" +
    "\n" +
    ".mdw-actions-wrap-transclude {\r" +
    "\n" +
    "  float: right;  \r" +
    "\n" +
    "}\r" +
    "\n" +
    ".mdw-actions-wrap-transclude > a {\r" +
    "\n" +
    "  font-size: 13px;\r" +
    "\n" +
    "  padding: 4px 6px;\r" +
    "\n" +
    "}\r" +
    "\n" +
    "@media (max-width: {{wrapWidth}}) {\r" +
    "\n" +
    "  .mdw-actions-wrap-transclude {\r" +
    "\n" +
    "    float: left;\r" +
    "\n" +
    "    margin-top: 10px;\r" +
    "\n" +
    "    margin-left: 20px;\r" +
    "\n" +
    "  }\r" +
    "\n" +
    "}\r" +
    "\n" +
    "</style>\r" +
    "\n" +
    "<div class=\"mdw-actions-wrap-transclude\">\r" +
    "\n" +
    "  <div ng-transclude></div>\r" +
    "\n" +
    "</div>"
  );


  $templateCache.put('ui/panel-collapse.html',
    "<a href=\"\" class=\"mdw-panel-collapse\" title=\"{{isCollapsed ? 'Expand' : 'Collapse'}}\" \r" +
    "\n" +
    "  ng-click=\"isCollapsed =! isCollapsed\">\r" +
    "\n" +
    "  <span class=\"glyphicon glyphicon-chevron-{{isCollapsed == true ? 'down' : 'up'}}\"></span>\r" +
    "\n" +
    "</a>"
  );


  $templateCache.put('ui/values.html',
    "<form name=\"valuesForm\" class=\"form-horizontal\" role=\"form\">\r" +
    "\n" +
    "  <div ng-repeat=\"value in values\" class=\"form-group\" ng-class=\"{'has-error': value.error}\">\r" +
    "\n" +
    "    <label class=\"control-label col-xs-2\" ng-class=\"{'mdw-required': value.display == 'Required'}\" for=\"value.name\">\r" +
    "\n" +
    "      {{value.label ? value.label : value.name}}\r" +
    "\n" +
    "    </label>\r" +
    "\n" +
    "    <div ng-class=\"value.isDocument ? 'col-md-10' : 'col-xs-4'\">\r" +
    "\n" +
    "      <!-- TODO: currently unsupported: collections, numbers -->\r" +
    "\n" +
    "      <!-- TODO: add this once value labels become links: ng-style=\"{'overflow-y': value.editable ? 'auto' : 'hidden'}\" -->\r" +
    "\n" +
    "      <textarea ng-if=\"value.isException\" class=\"form-control mdw-document-input\"\r" +
    "\n" +
    "        rows=\"{{value.showLines}}\" id=\"{{value.name}}\" name=\"{{value.name}}\" ng-readonly=\"true\">{{asException(value)}}</textarea>\r" +
    "\n" +
    "      <textarea ng-if=\"value.isDocument && !value.isException\" class=\"form-control mdw-document-input\" \r" +
    "\n" +
    "        rows=\"{{value.showLines}}\" id=\"{{value.name}}\" name=\"{{value.name}}\" \r" +
    "\n" +
    "        ng-model=\"value.value\" ng-readonly=\"!value.editable\" ng-change=\"dirty(value)\">\r" +
    "\n" +
    "      </textarea>\r" +
    "\n" +
    "      <input type=\"checkbox\" ng-if=\"value.type === 'java.lang.Boolean'\" class=\"checkbox mdw-boolean-input\" \r" +
    "\n" +
    "        id=\"{{value.name}}\" name=\"{{value.name}}\" ng-model=\"value.value\" ng-readonly=\"!value.editable\" ng-change=\"dirty(value)\">\r" +
    "\n" +
    "      <div ng-if=\"value.type === 'java.util.Date'\">\r" +
    "\n" +
    "        <input type=\"text\" class=\"form-control mdw-date-input\" ng-style=\"{width: (dateDisplayFormat.length * 10) + 'px'}\"\r" +
    "\n" +
    "          id=\"{{value.name}}\" name=\"{{value.name}}\" ng-model=\"value.value\" ng-readonly=\"!value.editable\" ng-change=\"dirty(value)\"                \r" +
    "\n" +
    "          uib-datepicker-popup={{dateDisplayFormat}} is-open=\"datePopups[value.name]\">\r" +
    "\n" +
    "        <button type=\"button\" ng-if=\"value.editable\" class=\"btn mdw-btn btn-default mdw-float-left\" \r" +
    "\n" +
    "          ng-click=\"openDatePopup(value.name)\" >\r" +
    "\n" +
    "          <i class=\"glyphicon glyphicon-calendar\"></i>\r" +
    "\n" +
    "        </button>\r" +
    "\n" +
    "      </div>\r" +
    "\n" +
    "      <input type=\"text\" ng-if=\"!value.isDocument && value.type !== 'java.lang.Boolean' && value.type !== 'java.util.Date'\" \r" +
    "\n" +
    "        class=\"form-control\" \r" +
    "\n" +
    "        id=\"{{value.name}}\" name=\"{{value.name}}\" ng-model=\"value.value\" ng-readonly=\"!value.editable\" ng-change=\"dirty(value)\">\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "</form>"
  );


  $templateCache.put('ui/workflow.html',
    "<div class=\"mdw-workflow\">\r" +
    "\n" +
    "  <div>\r" +
    "\n" +
    "    <canvas class=\"mdw-canvas\"></canvas> \r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "  <div class=\"mdw-inspector\" mdw-inspector style=\"display:none\">\r" +
    "\n" +
    "    <div class=\"panel panel-default mdw-inspector-panel\">\r" +
    "\n" +
    "      <div class=\"panel-heading mdw-heading\">\r" +
    "\n" +
    "        <div class=\"mdw-heading-label\">\r" +
    "\n" +
    "          Inspector{{workflowObject.name || workflowType == 'transition' ? ': ' : ''}}\r" +
    "\n" +
    "          <span class=\"mdw-heading-sub\">{{workflowType == 'transition' ? 'Transition' : workflowObject.name}}</span>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "        <div class=\"mdw-heading-actions\">\r" +
    "\n" +
    "          <a class=\"btn mdw-inspector-btn\" ng-click=\"initInspector()\">\r" +
    "\n" +
    "            <span class=\"glyphicon glyphicon-minus\"></span>\r" +
    "\n" +
    "          </a> \r" +
    "\n" +
    "          <a class=\"btn mdw-inspector-btn\" ng-click=\"maxInspector()\">\r" +
    "\n" +
    "            <span class=\"glyphicon glyphicon-unchecked\"></span>\r" +
    "\n" +
    "          </a> \r" +
    "\n" +
    "          <a class=\"btn mdw-inspector-btn\" ng-click=\"closeInspector()\">\r" +
    "\n" +
    "            <span class=\"glyphicon glyphicon-remove\"></span>\r" +
    "\n" +
    "          </a>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "      </div>\r" +
    "\n" +
    "      <div class=\"mdw-inspector-content\">\r" +
    "\n" +
    "        <ul class=\"nav mdw-inspector-tabs\">\r" +
    "\n" +
    "          <li ng-repeat=\"(name, tab) in tabs\" ng-class=\"{'mdw-inspector-tab-active': tab === activeTab}\">\r" +
    "\n" +
    "            <a href=\"\" ng-click=\"setActiveTab(name)\">{{name}}</a>\r" +
    "\n" +
    "          </li>\r" +
    "\n" +
    "        </ul>\r" +
    "\n" +
    "        <!-- tab values for object -->\r" +
    "\n" +
    "        <div class=\"mdw-inspector-values\" ng-if=\"!activeTabValues[0].values && !drilledValue\">\r" +
    "\n" +
    "          <div class=\"mdw-markdown-content\" ng-if=\"activeTabValues[0].isMarkdown\" ng-bind-html=\"activeTabValues[0].value | markdown | unsafe\">\r" +
    "\n" +
    "          </div>\r" +
    "\n" +
    "          <div ng-repeat=\"tabValue in activeTabValues\" ng-if=\"!drilledValue && !activeTabValues[0].isMarkdown\" style=\"display:flex\">\r" +
    "\n" +
    "            <div class=\"mdw-inspector-label\" ng-if=\"tabValue.name && tabValue.extended\">\r" +
    "\n" +
    "              <a href=\"\" ng-click=\"drillIn(tabValue)\">{{tabValue.name}}</a>:\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "            <div class=\"mdw-inspector-label\" ng-if=\"tabValue.name && !tabValue.extended\">\r" +
    "\n" +
    "              {{tabValue.name}}:\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "            <div class=\"mdw-inspector-value\" ng-if=\"tabValue.asset.path && tabValue.asset.url\">\r" +
    "\n" +
    "              <a href=\"{{tabValue.asset.url}}\">{{tabValue.asset.path}}</a> {{tabValue.asset.version}}\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "            <div class=\"mdw-inspector-value\" ng-if=\"tabValue.url\">\r" +
    "\n" +
    "              <a href=\"{{tabValue.url}}\">{{tabValue.value}}</a>\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "            <div class=\"mdw-inspector-value\" ng-if=\"tabValue.name && !tabValue.url && (!tabValue.asset.path || !tabValue.asset.url)\">\r" +
    "\n" +
    "              {{tabValue.value}}\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "          </div>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "        <!-- tab values for array of object -->\r" +
    "\n" +
    "        <div class=\"mdw-inspector-values\" ng-if=\"activeTabValues[0].values && !drilledValue\">\r" +
    "\n" +
    "          <div ng-repeat=\"tabValue in activeTabValues\" ng-if=\"!drilledValue\">\r" +
    "\n" +
    "            <div class=\"mdw-inspector-value\" ng-if=\"tabValue.names && $index == 0\">\r" +
    "\n" +
    "              <span class=\"mdw-pre\" ng-repeat=\"name in tabValue.names\"><span class=\"mdw-ul\">{{name.name}}</span>{{name.pad}}</span>\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "            <div class=\"mdw-inspector-value\" ng-if=\"tabValue.values\">\r" +
    "\n" +
    "              <span class=\"mdw-pre\" ng-repeat=\"value in tabValue.values\"><a href=\"{{value.url}}\" ng-if=\"value.url\">{{value.value}}</a><a href=\"\" ng-if=\"value.extended\" ng-click=\"drillIn(value)\">{{value.value}}</a><span ng-if=\"!value.url && !value.extended\">{{value.value}}</span>{{value.pad}}</span>\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "          </div>\r" +
    "\n" +
    "          <div class=\"mdw-resource-content\" ng-if=\"drilledValue\">\r" +
    "\n" +
    "            <pre><code class=\"mdw-code\" \r" +
    "\n" +
    "              ng-bind-html=\"drilledValue.value | highlight:drilledValue.language | unsafe\"></code></pre>\r" +
    "\n" +
    "          </div>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "        <!-- drilled-in value -->\r" +
    "\n" +
    "        <div class=\"mdw-inspector-values\" ng-if=\"drilledValue\">\r" +
    "\n" +
    "          <div class=\"mdw-resource-content\">\r" +
    "\n" +
    "            <pre><code class=\"mdw-code\" \r" +
    "\n" +
    "              ng-bind-html=\"drilledValue.full | highlight:drilledValue.language | unsafe\"></code></pre>\r" +
    "\n" +
    "          </div>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "      </div>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "  </div>\r" +
    "\n" +
    "</div>  "
  );

}]);


/***/ })
/******/ ]);